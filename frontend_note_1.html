<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="Good artists copy, best artists steal." />



  <meta name="keywords" content="Hexo, next" />





  <link rel="shorticon icon" type="image/x-icon" href="/image_16X16.ico?v=0.4.5.1" />


<meta name="description" content="&amp;lt;!doctype html&amp;gt;





h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote {
    margin: 0;
    padding: 0;
}
body {
    font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, Arial, sans-serif;
    font-size:">
<meta property="og:type" content="website">
<meta property="og:title" content="Jennifer's Blog">
<meta property="og:url" content="http://www.xiaojunxie.com/frontend_note_1.html">
<meta property="og:site_name" content="Jennifer's Blog">
<meta property="og:description" content="&amp;lt;!doctype html&amp;gt;





h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote {
    margin: 0;
    padding: 0;
}
body {
    font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, Arial, sans-serif;
    font-size:">
<meta property="og:updated_time" content="2015-09-18T13:15:22.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jennifer's Blog">
<meta name="twitter:description" content="&amp;lt;!doctype html&amp;gt;





h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote {
    margin: 0;
    padding: 0;
}
body {
    font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, Arial, sans-serif;
    font-size:">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'always'
  };
</script>

  <title>
  

  
     | Jennifer's Blog
  
</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?aaeb08de6fdb9affd9d54c000b8b03e9";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">Jennifer's Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            <i class="menu-item-icon icon-next-categories"></i> <br />
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-resume">
          <a href="/resume" rel="section">
            <i class="menu-item-icon icon-next-resume"></i> <br />
            简历
          </a>
        </li>
      

      
      
    </ul>
  

  
    <div class="site-search">
      
  
  <form class="site-search-form">
    <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
  </form>


<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'ZkscG_mtxP6MWnAVkuLP','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 

  <div id="posts" class="posts-expand">
    
    
      <!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote {
    margin: 0;
    padding: 0;
}
body {
    font-family: "Helvetica Neue", Helvetica, "Hiragino Sans GB", Arial, sans-serif;
    font-size: 13px;
    line-height: 18px;
    color: #737373;
    background-color: white;
    margin: 10px 13px 10px 13px;
}
table {
	margin: 10px 0 15px 0;
	border-collapse: collapse;
}
td,th {	
	border: 1px solid #ddd;
	padding: 3px 10px;
}
th {
	padding: 5px 10px;	
}

a {
    color: #0069d6;
}
a:hover {
    color: #0050a3;
    text-decoration: none;
}
a img {
    border: none;
}
p {
    margin-bottom: 9px;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    color: #404040;
    line-height: 36px;
}
h1 {
    margin-bottom: 18px;
    font-size: 30px;
}
h2 {
    font-size: 24px;
}
h3 {
    font-size: 18px;
}
h4 {
    font-size: 16px;
}
h5 {
    font-size: 14px;
}
h6 {
    font-size: 13px;
}
hr {
    margin: 0 0 19px;
    border: 0;
    border-bottom: 1px solid #ccc;
}
blockquote {
    padding: 13px 13px 21px 15px;
    margin-bottom: 18px;
    font-family:georgia,serif;
    font-style: italic;
}
blockquote:before {
    content:"\201C";
    font-size:40px;
    margin-left:-10px;
    font-family:georgia,serif;
    color:#eee;
}
blockquote p {
    font-size: 14px;
    font-weight: 300;
    line-height: 18px;
    margin-bottom: 0;
    font-style: italic;
}
code, pre {
    font-family: Monaco, Andale Mono, Courier New, monospace;
}
code {
    background-color: #fee9cc;
    color: rgba(0, 0, 0, 0.75);
    padding: 1px 3px;
    font-size: 12px;
    -webkit-border-radius: 3px;
    -moz-border-radius: 3px;
    border-radius: 3px;
}
pre {
    display: block;
    padding: 14px;
    margin: 0 0 18px;
    line-height: 16px;
    font-size: 11px;
    border: 1px solid #d9d9d9;
    white-space: pre-wrap;
    word-wrap: break-word;
}
pre code {
    background-color: #fff;
    color:#737373;
    font-size: 11px;
    padding: 0;
}
sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:10px auto;
    }
}
@media print {
	body,code,pre code,h1,h2,h3,h4,h5,h6 {
		color: black;
	}
	table, pre {
		page-break-inside: avoid;
	}
}
</style>
<title>前端学习笔记-1[^1]</title>
<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax:{inlineMath:[['$$$','$$$']]}});</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<h1>前端学习笔记-1<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h1>

<h2>基础知识</h2>

<h3>HTML--搭建结构</h3>

<ol>
<li><p>语义化的HTML</p>

<p> <em>header footer nav main section article</em>这些语义化的元素可以方便自动程序的识别。（解决ie下不支持HTML5新特性的方法：html5shiv.js）</p>

<p> 包含语义的标签，恰当的表示文档结构</p>

<p> <em>css语义化</em>是指为html添加有意义的id、class等补充未表达的语义</p>

<p> <strong>web语义化</strong>的意义</p>

<ul>
<li><p>赋予标签含义，让代码结构更加清晰，虽然我们可以在标签上添加 class 来标识，但这种通过属性来表示本体的形式会显得不够直接，而且在一定程度上也有冗余。</p></li>
<li><p>优化搜索引擎（SEO），结构良好的网页对搜索引擎的亲和力是很高的，百度和 google 也给出了很多网页结构化的建议（规范），方便他们抓取网页。</p></li>
<li><p>利于设备解析，如盲人阅读器对页面的分析，目前淘宝很多网页都是支持盲人阅读的，这种体验上的优化得利于网页的良好结构和语义化表达。</p></li>
<li><p>便于开发者维护，在参加工作之前，很多程序员都是单人开发模式，单人开发无所谓代码结构，自己看得懂就差不多了，一旦走向工作岗位，会发现，以前的鄙习有点让自己捉襟见肘了，有利于团队项目的可持续运作与维护</p></li>
</ul>
</li>
<li><p><strong>doctype</strong>的作用</p>

<p> 声明页面文档的类型，告诉浏览器应该使用哪种模式进行渲染。如：HTML5&lt;!DOCTYPE html></p></li>
<li><p>cookie、webStorage(sessionStorage、localStorage)、webSQL区别，从生存周期和持久化角度考虑</p>

<ul>
<li><p>cookie：容量受限，且不能跨域传输，解决可以参考jsonp</p>

<ol>
<li><p> 每个域名存储量比较小（各浏览器不同，大致4K）</p></li>
<li><p> 所有域名的存储量有限（各浏览器不同，大致4K）</p></li>
<li><p> 有个数限制（各浏览器不同）</p></li>
<li><p> <em>会随请求发送到服务器</em></p></li>
</ol>
</li>
<li><p>sessionStorage：sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是<em>会话级别</em>的存储。</p>

<ol>
<li><p> 只在session内有效</p></li>
<li><p> 存储量更大（推荐没有限制，但是各浏览器不同）</p></li>
</ol>
</li>
<li><p>localStorage：localStorage用于<em>持久化的本地存储</em>，除非主动删除数据，否则数据是永远不会过期的。</p>

<ol>
<li><p> 永久存储</p></li>
<li><p> 单个域名存储量比较大（推荐5MB，各浏览器不同）</p></li>
<li><p> 总体数量无限制</p></li>
</ol>
</li>
<li><p><em>websqldatabase</em>本地数据库</p>

<ol>
<li><p> 用javascript写sql查询，数据库就在浏览器里面，Safari、chrome、opera已经支持啦。</p></li>
<li><p> 数据库在本地，大大提高了web应用程序的性能，减轻了服务器的压力。</p></li>
<li><p> localStorage是KV结构，而websql是SQL（schema，NoSqL），性能不如webstorage，貌似已经面临被砍的囧境</p></li>
</ol>
</li>
</ul>
</li>
<li><p>如何对网页添加多语言支持</p>

<p> <strong><em>!+[1,]是世界上最短IE判断，但是在IE9及以上版本已经进行了修复，还可以使用!window.VBArray进行判定</em></strong></p>

<pre><code> var lang = !+[1,] ? navigator.uerlanguage : navigator.language;
 switch(lang){
     case 'zh-CN': //显示中文操作
         break;
     ...
 }
</code></pre></li>
<li><p>HTTP method：<strong>GET和POST的区别</strong></p>

<ul>
<li><p>GET通常用于向服务器获取数据，将参数放到URL的query string中，有长度限制，只支持ASCII数据，存在信息泄露的危险</p></li>
<li><p>POST常用于向服务器输入数据，如提交表单，将参数放到HTTP body中</p></li>
</ul>
</li>
<li><p><strong>SVG</strong>可伸缩矢量图使用</p>

<p> <a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial" target="_blank" rel="external">SVG教程</a></p>

<p> SVG图标实际上是一个服务于浏览器的XML文件，而不是一个字体或像素的位图。他是由浏览器直接渲染XML，在任何大小之下都会保持图像清晰，而且文件中的XML还提供了很多机会，可以直接在代码中使用动画或者修改颜色等。</p></li>
<li><p><a href="http://www.atatech.org/articles/26343" target="_blank" rel="external">响应式设计</a></p>

<p> 媒体查询：@media query link的media属性</p>

<p> 流式布局：使用em或百分比作单位；使用液态/弹性图片；css3(使用srcset属性根据屏幕大小引入源；column-count属性实现列布局；flexbox使用)，微软的网格grid布局，类似bootstrap的栅格系统</p>

<pre><code> display: -ms-grid
 -ms-grid-columns: 200px 20px auto 20px 200px;//3列，间距为20px
 -ms-grid-rows: auto 1fr;//2行，第2行占10%；
</code></pre></li>
<li><p>HTML5新增元素</p>

<ul>
<li><p>datalist</p>

<pre><code>  &lt;input list="country"&gt;
  &lt;datalist id="country"&gt;
      &lt;option value=""&gt;xxx&lt;/option&gt;
  &lt;/datalist&gt;
</code></pre></li>
<li><p>canvas</p>

<pre><code>  var canvas = document.getElementById('canvas'),
      ctx = canvas.getContext('2d');
  ctx.beginPath();
  ctx.moveTo(xpos, ypos);
  ctx.lineTo(xpos, ypos);
  ctx.closePath();
  ctx.fill/stroke[style]();   
</code></pre></li>
</ul>
</li>
<li><p>HTML判断浏览器类型</p>

<pre><code> &lt;!-- [if lte IE 9]&gt;
     ...
 &lt;![end if]--&gt;
</code></pre></li>
<li><p>面试题小结</p>

<ul>
<li>img的title和alt：title是一个<strong>全局属性</strong>，用于给图片附加信息，当鼠标滑动到元素上的时候显示；alt替代文本是img的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片，可提高图片的访问性，除装饰图片外都必须设置有意义的值，搜索引擎会重点分析，有助于SEO</li>
</ul>
</li>
<li><p><strong>HTML布局</strong></p>

<ol>
<li>div</li>
<li>table</li>
<li><p><strong>flexbox</strong>（css3弹性方框模型）</p>

<ul>
<li>如何正确使用flex-box弹性布局，配合media-query可用为响应式布局带来新的可能。其核心在于内含item的尺寸可用是弹性的，container可用根据本身尺寸的变化来动态地调整item的尺寸，当container中有空白空间时，item可用扩展尺寸以占据额外的空间，当容器中的空间不足时，item可用缩小尺寸，类似于table中的td，大大简化了因浏览器大小的变化对内容布局产生的影响。</li>
</ul>


<p> <a href="http://www.w3cplus.com/css3/a-visual-guide-to-css3-flexbox-properties.html" target="_blank" rel="external">图解CSS3 flexbox</a></p>

<pre><code>     #flexbox{
         width: 500px;
         height: 80px;
         border: 1px solid black;

         display: -webkit-box;
         -webkit-box-orient: horizontal;

         display: -moz-box;
         -moz-box-orient: horizontal;

         display: box;
         box-orient: horizontal;
     }
     #flexbox &gt; div{
         -webkit-box-flex: 1;
         -moz-box-flex: 1;
         box-flex: 1;

         -webkit-transition: width 0.7s ease-out;
         -moz-transition: width 0.7s ease-out;
         -ms-transition: width 0.7s ease-out;
         -o-transition: width 0.7s ease-out;
         transition: width 0.7s ease-out;
     }
     #flexbox &gt; div:nth-child(1){
         background-color: red;
     }
     #flexbox &gt; div:nth-child(2){
         background-color: green;
     }
     #flexbox &gt; div:nth-child(3){
         background-color: blue;
     }

     #flexbox &gt; div:hover{
         width: 200px;
     }

     实现：div1 div3 是固定宽度 div2 是自适应宽度
     #flexbox{
         width: 100%;
         height: 100px;

         display: -webkit-box;
         -webkit-box-orient: horizontal;
         display: -moz-box;
         -moz-box-orient: horizontal;
         display: box;
         box-orient: horizontal;
     }
     #flexbox &gt; div:nth-child(1){
         background-color: red;
         width: 400px;
     }

     #flexbox &gt; div:nth-child(2){
         -webkit-box-flex: 1;
         -moz-box-flex: 1;
         box-flex: 1;
         background-color: green;
     }

     #flexbox &gt; div:nth-child(3){
         background-color: blue;
         width: 400px;
     }

     &lt;div id="flexbox"&gt;
         &lt;div&gt;&lt;/div&gt;
         &lt;div&gt;&lt;/div&gt;
         &lt;div&gt;&lt;/div&gt;
     &lt;/div&gt;

     display: box //version of 2009
     display: flexbox //version of 2011
     display: flex //actual version

     //to use flex-box
     display: -webkit-box;
     display: -moz-box;
     display: -ms-felxbox;
     display: -webkit-flex;
     display: flex;
</code></pre></li>
</ol>
</li>
<li><p>HTML5与页面显示相关的API</p>

<p>page visibility在页面变为最小化或者用户将浏览器标签切换到其他标签时会触发</p>

<pre><code>document.hidden
document.visibilityState
监听visibilityChange事件
</code></pre>

<p>fullscreen是将页面整体或页面中某个局部区域设为全屏</p>

<pre><code>document.documentElement.requestFullScreen
document.exitFullscreen/mozCancelFullScreen/webkitCancelFullScreen
监听fullscreenChange事件
</code></pre></li>
</ol>


<h3>CSS--设计样式</h3>

<ol>
<li><p><strong>CSS reset</strong>文件</p>

<p> CSS reset文件可以重置浏览器对于HTML元素的默认样式，作用是<em>让各个浏览器的CSS样式有一个统一的基准</em>。<a href="http://www.cssreset.com/" target="_blank" rel="external">下载地址</a></p>

<p> PC时代各种浏览器、各种标准，造成对于HTML的各个标签的默认样式不同，造成各个平台样式难以统一，引入reset对默认样式进行重置，方便在各个平台进行统一开发。跨入无线web时代后，依然存在碎片化问题，但是由于无线web上各个厂商对很多规范都进行了支持，不一定需要reset，只需要做个统一化处理，这就是reset和normalize之争。</p></li>
<li><p>display position float clear</p>

<ul>
<li><p>display：none/block/inline-block/inline(没有width、height属性)/table/list-item/<strong>flexbox</strong>弹性布局</p>

<p>  display:none 文档不会渲染</p>

<p>  visibility:hidden 文档会渲染(占空间)只是不显示，依然存在在文档流中</p></li>
<li><p>position:</p>

<ul>
<li>static 默认样式，不受TRBL影响，不会被特殊定位</li>
<li><p>fixed 相对于浏览器<strong>窗口</strong>固定，即使页面滚动位置也不变，返回顶部</p>

<pre><code>  $('body,html').animate({scrollTop:0},100);
</code></pre></li>
<li><p>relative  位置相对于父元素，通常用来做absolute元素的内容块</p></li>
<li>absolute  相对于<strong>最近的已定位祖先元素</strong>位置固定，祖先元素都没有position属性时，同fixed</li>
</ul>


<p>  <em>使用CSS实现元素（包括文本、图片等）绝对居中</em></p>

<pre><code>  1. inline元素为父元素设置text-align: center;
  2. block元素1)元素设置宽度,2)左右margin:auto,3)IE6下父元素设置text-align: center,再给子元素恢复需要的值
  3. float元素1)元素设置宽度,2)position: relative3)浮动偏移量left/right设置为50%4)margin设置为宽度一半乘以-1
  4. absolute元素
  &lt;style&gt;
      .absolute_center{
          position: absolute;
          overflow: auto;
          width: 800px;
          height: 600px;
          /*
          margin: auto;
          top: 0;
          right: 0;
          bottom: 0;
          left: 0;
          */
          margin-left: -400px;
          left: 50%;

          background:pink url("background.png") no-repeat center;
      }
      p{
          color: white;
          text-align: center;
          /*vertical-align: center;//针对行内可替换元素*/
          line-height: 600px; 
      }
      ::selection{
          color: red;
      }
  &lt;/style&gt;
  &lt;div class="absolute_center"&gt;
      &lt;p&gt;完全居中&lt;/p&gt;
  &lt;/div&gt;
  5. flexbox实现绝对居中
  .centerbox {
      width: 350px;
      height: 95px;
      font-size: 14px;
      border: 1px solid #555;
      background: #CFC;

      display: box;//-webkit/moz-
      box-orient: horizontal;
      box-pack: center;
      box-align: center;
  }
  6. 使用transform属性
  .center_horizontal {
      position: relative;
      left: 50%;
      transform: translateX(-50%);
  }
  .center_vertical {
      position: relative;
      top: 50%;
      transform: translateY(-50%);
  }
  7. 固定尺寸的img 在固定尺寸的div中怎么水平居中，竖直居中；引申：不定尺寸的img 在固定尺寸的div中怎么水平居中，竖直居中, 写出img 和 div的css规则
  div{
      width: 800px;
      height: 600px;
      border: 1px solid red;
      position: relative;
  }

  img{
      /*
      width: 400px;
      height: 400px;
      margin-left: 200px;
      margin-top: 100px;
      */
      position: absolute;
      margin: auto;
      top: 0;         
      right: 0;
      bottom: 0;
      left: 0;
  }
</code></pre></li>
<li><p>z-index：设置重叠</p></li>
<li><p>float：left/right 只可以水平浮动</p></li>
<li><p><strong>清除浮动还是闭合浮动</strong></p>

<pre><code>  (1)清除浮动对应着CSS中的属性是clear：none|left|right|both
  (2)而闭合浮动是使浮动元素闭合，从而减少浮动带来的影响

  .clearfix:after {
      clear: both; 
      content: "."; /*Firefox中为空仍然会产生额外的空隙，但是此值为空时不需要height：0和visibility：hidden*/
      display: block; 
      height: 0; /*避免生成内容对原有布局的高度产生影响*/
      font-size: 0;
      line-height: 0;
      visibility: hidden;
  }
  .clearfix {*zoom: 1;}/*清除ie6-7下的浮动，作用大致是触发 hasLayout*/

  CSS定位机制：普通流（normal flow），浮动，绝对定位（position: fixed 是 position: absolute 的一个子类）

  清理浮动的各种方法类型：
  1）在浮动元素末尾添加空元素，设置clear: both
  2) 触发BFC，IE下还要触发hasLayout

  精益求精清除浮动    
  /**
  * 在标准浏览器下使用
  * 1 content内容为空格用于修改opera下文档中出现contentEditable属性时在清理浮动元素上下的空白
  * 2 使用display:table可以防止容器和子元素top-margin折叠，这样能使清理效果与BFC，IE6/7下的zoom：1一致
  **/
  .clearfix:before,
  .clearfix:after {
      content: " "; /* 1 */
      display: table; /* 2*/
  }
  .clearfix:after {
      clear: both;
  }
  /**
  * IE6/7下使用
  * 通过触发hasLayout实现包含浮动
  **/
  .clearfix {
      *zoom: 1;
  }
</code></pre></li>
</ul>
</li>
<li><p><a href="http://alistapart.com/article/sprites" target="_blank" rel="external">CSS sprites（雪碧图）</a></p>

<p> 将一些小图片整合到一张大图里面，来达到<em>减少HTTP请求</em>的目的。一般把单页需要的整合到一张，整站需要的整合到一张，可以避免加重当前页不需要的图片，还可以把色值相近的图片放到一起，让压缩的图片体积更小。早期的CSS Sprites使用的都是位图，而且为了适合web页面使用环境，采用的都是.png文件格式，但在现在只使用位图，会受到很多的限制，比如在r屏下，位图会模糊，也就是说，为了适配各种终端设备分辨，CSS Sprites将不再局限于位图，也可以将SVG这样的矢量图集合在一起。</p>

<p> <a href="http://www.atatech.org/articles/37769" target="_blank" rel="external">web中的图标</a></p>

<p> 随着时代的变迁与技术的不断地更新，在当今这个时代，web中的图标不再仅仅是局限于img，除了img直接调用icons文件之外，还有Sprites、Iconfont（字体图标）、SVG ICon等等。<strong>设计师不管分辨率和设备平台，他们追求的是像素完美和体验一致性，而前端工程师更为关心的是页面的可访问性、性能以及重构的灵活性、可复用性、可维护性等等</strong>。而当下这个互联网时代，设备多样化，显示分辨率层出不穷，对于web前端工程师来说可是灾难，碰到的难题也是越来越多：</p>

<ol>
<li>需要为高PPI显示设备准备1.5X、2X和3X的图标素材</li>
<li>需要针对不同分辨率来调整优化排版</li>
<li>需要考虑不同平台下图片加载的性能问题</li>
<li>需要考虑可访问性、可维护性问题</li>
</ol>


<p> 下面，对几种web图标进行对比：</p>

<table>
<thead>
<tr>
<th>web图标</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>img</td>
<td>1.更换简单；<br>2.图标大小易掌握</td>
<td>1.增加HTTP请求数；<br>2.不易匹配各种终端和分辨率，可能会造成图标模糊；<br>3.不易修改图标样式，比如颜色、阴影等；<br>4.不易维护</td>
</tr>
<tr>
<td>sprites</td>
<td>1.减少HTTP请求数；<br>2.可以是任意图形、任意色彩；<br>3.兼容性好（just位图）</td>
<td>1.增加开发时间，需要人工进行各种图片的合成，图片的色彩对于web性能有直接的影响；<br>2.增加维护成本；<br>3.图片尺寸固定，无法通过CSS来修改图标大小，但SVG的Sprites可以配合CSS的background-size来调整图标的大小</td>
</tr>
<tr>
<td>Icon Font</td>
<td>1.减少HTTP请求；<br>2.很容易任意缩放（font-size）、改变颜色（color）、产生阴影（text-shadow）、透明效果等等；<br>3.兼容性好；<br>4.本身体积更小</td>
<td>1.只能被渲染成单色或者CSS3的渐变色；<br>2.使用限制性大，需要自己去创作；<br>3.在不同的设备浏览器字体的渲染会略有差别，在不同的浏览器或系统中对字体的渲染不同，其显示的位置和大小可能会受到font-size、line-height、word-spacing等CSS属性的影响，而且这种影响调整起来较为困难；<br>4.不兼容旧的手机浏览器</td>
</tr>
<tr>
<td>SVG</td>
<td>1.矢量图形文件，可以随意修改大小，而且不会影响图标质量；<br>2.可以使用CSS样式来定义图标颜色、尺寸等；<br>3.所以的SVG图标在一个SVG文件中，节省HTTP请求；<br>4.可以使用CSS或Javascript制作动画效果；<br>5.可以使用gzip压缩；<br>6.可以很精细的控制SVG图标的每一部分；</td>
<td>1.浏览器兼容性差；<br>2.需要了解制作SVG图形方法</td>
</tr>
<tr>
<td>Data Url</td>
<td>不增加请求数</td>
<td>1.通常比图片大10%；<br>2.每次加载都需要解码；<br>3.难于维护</td>
</tr>
</tbody>
</table>


<p> 那么，具体在使用时，如何选择呢：</p>

<ol>
<li>如果需要的是信息丰富的图片，而不仅仅是图标，那么使用img</li>
<li>如果不是展示类图形，而是装饰性的图形，一般不随意改懂，可以考虑使用png Sprites</li>
<li>如果图标需要适配于高分辨率环境下，可以考虑使用SVG Sprites</li>
<li>仅仅是需要Icon这些小图标，并且可以做一些个性化样式，可以考虑使用Icon Font</li>
<li>仅仅需要图标更具扩展性，又不希望加载额外的图标，可以考虑在页面中直接使用SVG代码绘制的矢量图</li>
</ol>


<p> 使用时参考<em>background-position</em>属性</p>

<ul>
<li>(left, center, right)x(top, center, bottom)</li>
<li>x% y%</li>
<li>xpos ypos</li>
<li>inherit</li>
</ul>
</li>
<li><p><em>使用文字替换图片技术</em>→有利于SEO</p>

<pre><code> &lt;h2&gt;&lt;span&gt;Hello world&lt;/span&gt;&lt;/h2&gt;
 h2{
     background: url(image.gif) no-repeat;
     width: 150px;
     height: 35px;
 }
 span{
     display: none;
 }           

 &lt;h1 class="nir"&gt;content&lt;/h1&gt;
 .nir{
     height: 100px;
     width: 400px;
     overflow: hidden;
 }
 .nir:before{
     content: url(image.gif);
     display: inline-block;
     font-size: 0;
     line-height: 0;
 }

 &lt;h2&gt;&lt;span&gt;&lt;/span&gt;Hello world&lt;/h2&gt;
 h2 {
     width: 150px;
     height: 35px;
     position: relative;
 }
 h2 span{
     background: url(image.gif) no-repeat;
     position: absolute;
     width: 100%;
     height: 100%;
 }
</code></pre></li>
<li><p>CSS hacks/<strong>浏览器兼容问题</strong></p>

<ol>
<li>属性hack</li>
<li>选择器hack</li>
<li><p>IE条件注释</p>

<pre><code> &lt;!-- [if lte IE 9]&gt;
     ...
 &lt;![end if]--&gt;
</code></pre></li>
</ol>


<p> <a href="http://blog.csdn.net/freshlover/article/details/12132801" target="_blank" rel="external">史上最全的CSS Hack方式一览</a></p></li>
<li><p>栅格系统</p>

<p>bootstrap：目前很好的css框架--from Twitter</p>

<p>微软的grid</p></li>
<li><p>CSS选择器 -- 优化</p>

<p> <a href="http://caniuse.com" target="_blank" rel="external">查看是否可用</a></p>

<ol>
<li><p>匹配顺序 <strong>从右向左</strong></p></li>
<li><p>匹配规则（根据主选择器进行划分）</p>

<ul>
<li>ID 规则</li>
<li>Class 规则</li>
<li>tag 规则</li>
<li>全局规则</li>
</ul>
</li>
<li>写法

<ul>
<li>css组合选择器

<ul>
<li>后代选择器 div p</li>
<li>子元素选择器 div>p</li>
<li>相邻兄弟选择器 div+p 相邻的兄弟</li>
<li>普通兄弟选择器 div~p 返回一组值</li>
</ul>
</li>
<li>css伪类

<ul>
<li>:link :visited :focus :hover :active(顺序很重要)</li>
<li>:first-child :nth-child(expression)</li>
<li>:focus :blur</li>
<li>:not :have</li>
</ul>
</li>
<li><p>css伪元素</p>

<ul>
<li>:first-letter :first-line</li>
<li>:before :after</li>
<li><p>::selection 匹配突出显示的文本 只接受2个属性：background和color</p>

<pre><code>  1. 注意伪元素和伪类的区别：first-letter vs first-child
  2. nth-of-type vs nth-child
      ele:nth-of-type(n)是指父元素下第n个ele子元素
      ele:nth-child(n)是指父元素下的第n个子元素，若类型为ele则命中，否则选择失败
</code></pre></li>
</ul>
</li>
<li><p>css属性选择器</p>

<ul>
<li>[attribute]</li>
<li>[attribute = value]</li>
<li>[attribute ~= value]包含</li>
<li>[attribute *= value]包含</li>
<li>[attribute |= value]以value开头且必须是一个单词</li>
<li>[attribute ^= value]以value开头</li>
<li>[attribute $= value]以value结尾</li>
<li>[:checked] [:selected]</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p><em>CSS盒模型</em></p>

<table>
<thead>
<tr>
<th>TRBL规则 </th>
<th> margin </th>
<th> border </th>
<th> padding </th>
<th> content</th>
</tr>
</thead>
<tbody>
<tr>
<td>------------</td>
<td> outer-width(true) </td>
<td> outer-width </td>
<td> inner-width </td>
<td> width</td>
</tr>
</tbody>
</table>


<p> CSS3中可以使用box-sizing改变盒模型</p>

<ul>
<li>content-box：默认值，标准盒模型，width和height是内容区的宽和高</li>
<li>padding-box：width和height包括内边距</li>
<li>border-box：wedth和height包括内边距和边框，这是<em>IE怪异模式</em>使用的盒模型</li>
</ul>
</li>
<li><p>什么是无样式内容闪烁<strong>FOUC</strong>，如何避免</p>

<p> 使用import方式对CSS进行导入时，会导致某些页面在windows下的IE上出现一些奇怪的现象，以无样式显示页面内容的瞬间闪烁，这种现象被称为文档样式短暂失效（Flash Of Unstyled Content），解决方法有</p>

<ul>
<li>避免使用import引入CSS</li>
<li><p>使用link标签将样式文件放到head部分而不是页面底部</p>

<pre><code>  &lt;link rel="dns-prefetch" href=""/&gt;  
  默认情况下浏览器会对页面中和当前不在同一个域的页面进行预获取，并且缓存结果，这就是隐式的DNS Prefetch。如果相对页面中没有出现的域进行预获取，那么就要使用显式的DNS Prefetch。

  &lt;meta http-eqiv="x-dns-prefetch-control" content="off"&gt;
  禁止隐式DNS Prefetch 
</code></pre></li>
</ul>
</li>
<li><p>link和@import的区别</p>

<ul>
<li>link是HTML方式，@import是CSS方式</li>
<li>link最大限度支持并下载，@import<strong>过度嵌套</strong>导致串行下载，出现9中所示FOUC</li>
<li>link可以通过rel="reference stylesheet"指定候选样式</li>
<li>浏览器对link支持早于@import，可以在CSS文件中引用其他文件</li>
</ul>


<p>总体来说link优于@import</p></li>
<li><p><em>CSS预处理器</em>（SASS Compass Stylus <em>LESS</em>）</p>

<ul>
<li><p>出现原因</p>

<p>  css作为一门标记性语言，语法相对简单，对使用者要求较低，但是也带来一些问题：css需要书写大量看似没有逻辑的代码，不方便维护及扩展，不利于复用，尤其对于非前端工程师来讲，往往会因为缺少css编写经验而很难<em>写出组织良好且易于维护的css代码</em>，造成这些困难的很大原因源于css是一门非程序式语言，没有变量、函数、作用域等概念。</p></li>
<li><p>优点</p>

<ol>
<li><p> 解决传统CSS无法使用变量、算数计算、条件判断等缺陷</p></li>
<li><p> Mixin混入技术</p></li>
<li><p> 提高代码开发效率</p></li>
</ol>
</li>
<li><p>缺点--需要额外学习成本</p></li>
<li><p>less--css框架</p>

<ul>
<li><p>基本概念：less为web开发者带来了福音，他在css的语法基础上，引入了<strong>变量、mixin、运算以及函数、命名空间、嵌套@变量&amp;伪类</strong>等功能，大大简化了css的编写，并且降低了css的维护成本，就像他的名称所说的那样，<em>less可以让我们用更少的代码做更多的事情</em>。方便css的书写和维护，但是less更接近css语法</p></li>
<li><p>使用：</p>

<pre><code>  1. sudo npm install -g less

  2. vim styles.less

      @base: #f938ab;

      .box-shadow(@style, @c) when (iscolor(@c)) {
          -webkit-box-shadow: @style @c;
          box-shadow: @style @c;
      }

      .box-shadow(@style, @alpha: 50%) when (isnumber(@alpha)) {
          .box-shadow(@style, rgba(0, 0, 0, @alpha));
      }

      .box {
          color: saturate(@base, 5%);
          border-color: lighten(@base, 30%);
          div {.box-shadow(0 0 5px, 30%)}
      }

  3. lessc styles.less -x(对css进行压缩) &gt; styles.css or cleancss -o styles.min.css styles.css

      .box {
        color: #fe33ac;
        border-color: #fdcdea;
      }
      .box div {
        -webkit-box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
      }

  4. &lt;link rel="stylesheet/less" type="text/css" href="styles.less"&gt; 
      &lt;script src="less.js" type="text/javascript"&gt;&lt;/script&gt;

  5. 下载less.js 或者 bower install less 或者 使用CDN加速
      &lt;script src="http://cdn.bootcss.com/less.js/2.4.0/less.min.js"&gt;&lt;/script&gt;
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p>CSS3实现英文单词完美显示</p>

<pre><code>&lt;html lang="en-US"&gt;//支持hyphens
    &lt;head&gt;
        &lt;style&gt;
            div{
                -moz-hyphens: auto;
                -ms-hyphens: auto;
                -webkit-hyphens: auto;
                hyphens: auto;
                word-wrap: break-word;
                //word-break: break-all;
            }
        &lt;/style&gt;
    &lt;/head&gt;
&lt;/html&gt;
</code></pre>

<ul>
<li>word-wrap: 允许长单词或URL地址换到下一行，取值有normal/break-word</li>
<li>word-break: 自动换行处理方法，取值有normal/break-all/keep-all(只在半角空格或者连字符处换行)</li>
</ul>
</li>
<li><p>CSS3新增元素</p>

<ul>
<li>transform 转换

<ul>
<li>前缀 ms(IE9)/webkit(chrome/Safari)</li>
<li>取值 translate/rotate/scale/skew/matrix</li>
</ul>
</li>
<li>transition    过渡

<ul>
<li>前缀 webkit(Safari)/IE9及更早不支持</li>
<li>取值 [property duration timing-function delay], property duration timing-function delay</li>
</ul>
</li>
<li>animation &amp;&amp; @keyframes 动画

<ul>
<li><strong>前缀</strong> webkit(chrome/safari)</li>
<li><p>实例</p>

<pre><code>  div{
      animation: name duration timing-function delay iteration-count direction play-state;
  }
  @keyframes name{
      //from {css property}
      //to {css property}
      0% {css property}
      25% {css property}
      50% {css property}
      75% {css property}
      100% {css property}
  }
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>BFC 块级格式化上下文</strong> 可以看做是隔离了的独立容器</p>

<p>如何触发BFC：</p>

<ol>
<li>根元素默认拥有BFC特性</li>
<li>float: left | right</li>
<li>overflow: hidden | auto | scroll</li>
<li>display: table-cell | table-caption | inline-block</li>
<li><p>position: absolute | fixed</p>

<pre><code> 子元素不会溢出：
 &lt;div id="a"&gt;
     &lt;div id="b"&gt;...&lt;/div&gt;
     ...
 &lt;/div&gt;
 #a{
     overflow: hidden;
 }
 #b{
     max-width: 100%;
 }
</code></pre></li>
</ol>


<p>作用：</p>

<ul>
<li>阻止<strong>父子元素的外边距margin折叠</strong>，见15</li>
<li>不会重叠浮动元素</li>
<li>可以包含浮动元素</li>
</ul>


<p>通俗的来说，触发了BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，反之亦然，同时，BFC仍属于普通流</p>

<p>在IE6-7中显示引擎使用的是布局layout这个概念，当外面说一个元素拥有layout的时候，是指其hasLayout属性为true，拥有布局的元素负责本身和其子元素的尺寸设置和定位</p>

<p>如何触发hasLayout：</p>

<ol>
<li>position: absolute</li>
<li>float: left | right</li>
<li>display: inline-block</li>
<li>width: 除auto以外的任意值</li>
<li>height: 除auto以外的任意值，如height: 1%</li>
<li>zoom: 除normal以外的任意值</li>
<li>IE7中---overflow: hidden | auto | scroll</li>
</ol>
</li>
<li><p>margin折叠</p>

<ul>
<li>两个或多个毗邻的普通流中的块元素垂直方向上的margin折叠</li>
<li>浮动元素/inline-block/绝对定位元素的margin不会和垂直方向上的其他元素折叠</li>
<li>创建了BFC的元素不会和他的子元素发生margin折叠</li>
<li>元素自身的margin-top和margin-bottom相临时也会折叠</li>
</ul>
</li>
<li><p>使用1、2、3、5个标签画红十字150px×150px</p>

<pre><code>&lt;!DOCTYPE&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;style type="text/css"&gt;
        /**包裹div样式*/
        div.container{      
            width: 150px;       
            height:150px;       
            float:left;     
            margin:10px 0px 0px 10px;   
        }   
        /**用1个div标签实现*/ 
        .cross{     
            width:50px;     
            height:150px;       
            background:red;     
            vertical-align: middle;     
            position:relative;      
            left:50px;  
        }   
        .cross:before{      
            position: absolute;     
            top:50px;       
            left:-50px;             
            width:50px;     
            height:50px;        
            background:red;     
            vertical-align: middle;     
            content:""; 
        }   
        .cross:after{       
            position: absolute;     
            top:50px;       
            left:50px;              
            width:50px;     
            height:50px;        
            background:red;     
            vertical-align: middle;     
            content:""; 
        }   
        /**用2个div标签实现*/ 
        div.s_first{        
            position:relative;      
            top:50px;       
            left:0px;       
            width:150px;        
            height:50px;        
            background:red; 
        }   
        div.s_second{       
            position:relative;      
            top:-50px;      
            left:50px;      
            width:50px;     
            height:150px;       
            background:red; 
        }   
        /**用3个div标签实现*/ 
        div.t_first{        
            position:relative;      
            top:0px;        
            left:50px;      
            width:50px;     
            height:150px;       
            background:red; 
        }   
        div.t_second{       
            position:relative;      
            top:-100px;     
            left:0px;       
            width:50px;     
            height:50px;        
            background:red; 
        }   
        div.t_third{        
            position:relative;      
            top:-150px;     
            left:100px;     
            width:50px;     
            height:50px;        
            background:red; 
        }   
        /**用5个div标签实现*/ 
        div.f_first{        
            position:relative;      
            top:0px;        
            left:50px;      
            width:50px;     
            height:50px;        
            background:red; 
        }   
        div.f_second{       
            position:relative;      
            top:0px;        
            left:0px;       
            width:50px;     
            height:50px;        
            background:red; 
        }   
        div.f_third{        
            position:relative;      
            top:-50px;      
            left:50px;      
            width:50px;     
            height:50px;        
            background:red; 
        }   
        div.f_fourth{       
            position:relative;      
            top:-100px;     
            left:100px;     
            width:50px;     
            height:50px;        
            background:red; 
        }   
        div.f_fifth{        
            position:relative;      
            top:-100px;     
            left:50px;      
            width:50px;     
            height:50px;        
            background:red; 
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt; &lt;div class="cross"&gt;&lt;/div&gt;&lt;/div&gt;

    &lt;div class="container"&gt; 
        &lt;div class="s_first"&gt;&lt;/div&gt; 
        &lt;div class="s_second"&gt;&lt;/div&gt;
    &lt;/div&gt;

    &lt;div class="container"&gt; 
        &lt;div class="t_first"&gt;&lt;/div&gt; 
        &lt;div class="t_second"&gt;&lt;/div&gt;    
        &lt;div class="t_third"&gt;&lt;/div&gt;
    &lt;/div&gt;

    &lt;div class="container"&gt; 
        &lt;div class="f_first"&gt;&lt;/div&gt; 
        &lt;div class="f_second"&gt;&lt;/div&gt;    
        &lt;div class="f_third"&gt;&lt;/div&gt; 
        &lt;div class="f_fourth"&gt;&lt;/div&gt;    
        &lt;div class="f_fifth"&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></li>
<li><p>css绘制箭头</p>

<pre><code>/* 向上的箭头,类似于A,只有三个边，不能指定上边框 */ 
div.arrow-up { 
width: 0; 
height: 0; 
border-left: 5px solid transparent; /* 左边框的宽 */ 
border-right: 5px solid transparent; /* 右边框的宽 */ 
border-bottom: 5px solid #2f2f2f; /* 下边框的长度|高,以及背景色 */ 
font-size: 0; 
line-height: 0;} 
/* 向下的箭头 类似于 V */ 
div.arrow-down { 
width: 0; 
height: 0; 
border-left: 20px solid transparent; 
border-right: 20px solid transparent; 
border-top: 20px solid #f00; 
font-size: 0; 
line-height: 0; 
} 
/* 向左的箭头: 只有三个边：上、下、右。而 &lt;| 总体来看，向左三角形的高=上+下边框的长度。 宽=右边框的长度 */ 
div.arrow-left { 
width: 0; 
height: 0; 
border-bottom: 15px solid transparent; /* 下边框的高 */ 
border-top: 15px solid transparent; /* 上方边框的高 */ 
border-right: 15px solid yellow; /* 右边框的长度|宽度，以及背景色 */ 
font-size: 0; 
line-height: 0; 
} 
/* 向右的箭头: 只有三个边：上、下、左。而 |&gt; 总体来看，向右三角形的高=上+下边框的长度。 宽=左边框的长度 */ 
div.arrow-right { 
width: 0; 
height: 0; 
border-bottom: 15px solid transparent; /* 下边框的高 */ 
border-top: 15px solid transparent; /* 上方边框的高 */ 
border-left: 15px solid green; /* 左边框的长度|宽度，以及背景色  */
font-size: 0; 
line-height: 0; 
}
</code></pre></li>
<li><p>CSS+JS制作轮播</p>

<pre><code>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head&gt;
&lt;title&gt;carousel&lt;/title&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=gb2312"&gt;
&lt;!--把下面代码加到&lt;head&gt;与&lt;/head&gt;之间--&gt;
&lt;style type="text/css"&gt;
* {
 margin:0;
 padding:0;
}
html,body {
 height:100%;
 text-align:center;
}
img {
 border:0;
}
/*【————————————Ad show parts of the beginning————————————*/
.ad_show {
 position:absolute;
 width:270px;
 height:350px;
 top: 0;
 right: 0;
 left: 0;
 bottom: 0;
 margin: auto;
 overflow:hidden;
}
.ad_show .cover_b {
 bottom:0;
 left:55px;
 width:160px;
 height:20px;
 font:11px Arial;
 position:absolute;
 z-index:999;
 overflow:hidden;
 background: white;
}
.ad_show .cover_b img {
 cursor:pointer;
 cursor:hand;
 margin-top:7px;
 float:left;
}
.ad_show .cover_b img#adShowPre {
 margin-left:16px;
}
.ad_show .cover_b span {
 display:block;
 padding-top:5px;
 float:left;
}
.ad_show .cover_b span#adShowNow,.ad_show .cover_b span#adShowAll {
 width:27px;
 text-align:left;
}
.ad_show .cover_b span#adShowNow {
 color:#f00;
 text-align:right;
}
.ad_show #adShowImg {
 position:static;
 width:270px;
 height:350px;
 overflow:hidden;
}
.ad_show #adShowImg div {
 width:99999px;
 margin-top:0;
 margin-left:0;
}
.ad_show #adShowImg div img {
 width:270px;
 height:350px;
 float:left;
}

/*【————————————Ad show parts of the end————————————*/
&lt;/style&gt;
&lt;script type="text/javascript"&gt;
  function $(element) {
   if(!document.getElementById) { return false; }
   if (arguments.length &gt; 1) {
    for (var i = 0, elements = [], length = arguments.length; i &lt; length; i++) {
     elements.push($(arguments[i]));
     return elements;
    }
   }
   if (typeof element == "string") {
    element = document.getElementById(element);
    return element;
   }
  }

  function addOnloadEvent(func) {
   var oldOnload = window.onload;
   if(typeof oldOnload != "function") {
    window.onload = func;
   }
   else {
    window.onload = function() {
     oldOnload();
     func();
    }
   }
  }

  //取得外部class的属性值
  function getCurrentStyle(o) {
   if (o.currentStyle) {
    return o.currentStyle;
   }
   else {
    return document.defaultView.getComputedStyle(o,null);
   }
  }

  //取得第一个元素子节点
  function getFirstElementNode(o) {
   if(o.firstChild.nodeType == 1) {
    return o.firstChild;
   }
   if(o.firstChild.nextSibling.nodeType == 1) {
    return o.firstChild.nextSibling;
   }
   return null;
  }

  //将对象定时移动到某个位置
  function moveElement(elementID,final_x,final_y,interval,speed) {
   if(!$(elementID)) return false;
   var o = getFirstElementNode($(elementID));
   if(o.movement) {
    clearTimeout(o.movement);
   }
   var ypos = parseInt(o.style.marginTop);
   var xpos = parseInt(o.style.marginLeft);
   if(xpos == final_x &amp;&amp; ypos == final_y) {
    return true;
   }
   if(xpos &lt; final_x) {
    var dist = Math.ceil((final_x - xpos)/speed);
    xpos += dist;
   }
   if(xpos &gt; final_x) {
    var dist = Math.ceil((xpos - final_x)/speed);
    xpos -= dist;
   }
   if(ypos &lt; final_y) {
    var dist = Math.ceil((final_y - ypos)/speed);
    ypos += dist;
   }
   if(ypos &gt; final_y) {
    var dist = Math.ceil((ypos - final_y)/speed);
    ypos -= dist;
   }
   o.style.marginLeft = xpos + "px";
   o.style.marginTop = ypos + "px";
   var again = "moveElement('" + elementID + "'," + final_x + "," + final_y + "," + interval + "," + speed + ")";
   o.movement = setTimeout(again,interval);
  }

  //对被移动对象的属性进行设置
  function positionMessage(oo,oWidth,x) {
   var o1 = getFirstElementNode($(oo));
   var oStyles = getCurrentStyle(o1);
   o1.style.marginLeft = oStyles.marginLeft;
   o1.style.marginTop = oStyles.marginTop;
   var xposNow = -oWidth*x;
   moveElement(oo,xposNow,0,10,12);
  }

  function autoShow() {
   var oMover = getFirstElementNode($("adShowImg"));
   var adShowNow = $("adShowNow");
   var adShowAll = $("adShowAll");
   var allA = oMover.getElementsByTagName("a");
   var allALen = allA.length;
   var allALenSub = allALen - 1;
   if (opp &lt; allALenSub &amp;&amp; opp2 == 0) {
    positionMessage("adShowImg",270,opp + 1);
    adShowNow.innerHTML = parseInt(adShowNow.innerHTML) + 1;
    opp++;
    opp2 = 0;
   }
   else {
    if(opp != 0) {
     positionMessage("adShowImg",270,opp - 1);
     adShowNow.innerHTML = parseInt(adShowNow.innerHTML) - 1;
     opp--;
     opp2 = 1;
    }
    else {
     positionMessage("adShowImg",270,0);
     adShowNow.innerHTML = 1;
     opp = 0;
     opp2 = 0;
    }
   }
   oMover.orepeat = setTimeout(autoShow,3000);
   oMover.onmouseover = function() {
    clearTimeout(this.orepeat);
   }
   oMover.onmouseout = function() {
    this.orepeat = setTimeout(autoShow,3000);
   }
  }

  function clickShow() {
   opp = 0;
   opp2 = 0;
   var oMover = getFirstElementNode($("adShowImg"));
   var adShowPre = $("adShowPre");
   var adShowNext = $("adShowNext");
   var adShowNow = $("adShowNow");
   var adShowAll = $("adShowAll");
   var allA = oMover.getElementsByTagName("a");
   var allALen = allA.length;
   var allALenSub = allALen - 1;
   adShowNow.innerHTML = 1;
   adShowAll.innerHTML = allALenSub + 1;
   adShowPre.onclick = function() {
    if (opp != 0) {
     positionMessage("adShowImg",270,opp - 1);
     adShowNow.innerHTML = parseInt(adShowNow.innerHTML) - 1;
     opp--;
    }
    else {
     positionMessage("adShowImg",270, allALenSub);
     adShowNow.innerHTML = allALen;
     opp = allALenSub;
    }
   }
   adShowNext.onclick = function() {
    if (opp != allALenSub) {
     positionMessage("adShowImg",270,opp + 1);
     adShowNow.innerHTML = parseInt(adShowNow.innerHTML) + 1;
     opp++;
    }
    else {
     positionMessage("adShowImg",270, 0);
     adShowNow.innerHTML = 1;
     opp = 0;
    }
   }
  }

  function autoShowAll() {
   clickShow();
   setTimeout(autoShow,3000);
  }
&lt;/script&gt;
&lt;script type="text/javascript"&gt;
 addOnloadEvent(autoShowAll);
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--把下面代码加到&lt;body&gt;与&lt;/body&gt;之间--&gt;
&lt;div class="ad_show"&gt;
  &lt;div class="cover_b"&gt;
    &lt;img src="b.jpg" id="adShowPre" style="width: 35px;" /&gt;
    &lt;span id="adShowNow"&gt;&lt;/span&gt;
    &lt;span&gt;/&lt;/span&gt;
    &lt;span id="adShowAll"&gt;&lt;/span&gt;
    &lt;img src="b.jpg" id="adShowNext" style="width: 35px;"/&gt; 
  &lt;/div&gt;
  &lt;div id="adShowImg"&gt;
    &lt;div&gt;
      &lt;a href="#" target="_blank"&gt;&lt;img src="1.jpg" /&gt;&lt;/a&gt;
      &lt;a href="#" target="_blank"&gt;&lt;img src="2.jpg" /&gt;&lt;/a&gt;
      &lt;a href="#" target="_blank"&gt;&lt;img src="3.jpg" /&gt;&lt;/a&gt;
      &lt;a href="#" target="_blank"&gt;&lt;img src="4.jpg" /&gt;&lt;/a&gt;
      &lt;a href="#" target="_blank"&gt;&lt;img src="5.jpg" /&gt;&lt;/a&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></li>
<li><p>bootstrap实现轮播</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
   &lt;title&gt;Carousel&lt;/title&gt;
   &lt;link href="bootstrap.min.css" rel="stylesheet"&gt;
   &lt;script src="jquery-1.11.1.min.js"&gt;&lt;/script&gt;
   &lt;script src="bootstrap.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id="myCarousel" class="carousel slide" style="width: 400px; height: 500px; overflow: hidden; top: 0; right: 0; bottom: 0; left: 0; margin: auto; position: absolute;"&gt;
   &lt;!-- 轮播（Carousel）指标 --&gt;
   &lt;ol class="carousel-indicators"&gt;
      &lt;li data-target="#myCarousel" data-slide-to="0" class="active"&gt;&lt;/li&gt;
      &lt;li data-target="#myCarousel" data-slide-to="1"&gt;&lt;/li&gt;
      &lt;li data-target="#myCarousel" data-slide-to="2"&gt;&lt;/li&gt;
   &lt;/ol&gt;   
   &lt;!-- 轮播（Carousel）项目 --&gt;
   &lt;div class="carousel-inner"&gt;
      &lt;div class="item active"&gt;
         &lt;img src="1.jpg" alt="First slide"&gt;
      &lt;/div&gt;
      &lt;div class="item"&gt;
         &lt;img src="2.jpg" alt="Second slide"&gt;
      &lt;/div&gt;
      &lt;div class="item"&gt;
         &lt;img src="3.jpg" alt="Third slide"&gt;
      &lt;/div&gt;
   &lt;/div&gt;
   &lt;!-- 轮播（Carousel）导航 --&gt;
   &lt;a class="carousel-control left" href="#myCarousel" 
      data-slide="prev"&gt;&amp;lsaquo;&lt;/a&gt;
   &lt;a class="carousel-control right" href="#myCarousel" 
      data-slide="next"&gt;&amp;rsaquo;&lt;/a&gt;
&lt;/div&gt; 

&lt;/body&gt;
&lt;/html&gt;
</code></pre></li>
<li><p>实现浮层</p>

<pre><code>&lt;div class="modal" id="zero"&gt;
   &lt;div class="inner_modal"&gt;
     &lt;div class="close"&gt;x&lt;/div&gt;
     &lt;img src="images/div_by_zero.jpg"&gt;
     &lt;h1&gt;Oh crap! Did you divide by zero?&lt;/h1&gt;
   &lt;/div&gt;
 &lt;/div&gt;
 .modal {
    position: absolute;
    top: 70px;
    left: 0;
    right: 0;
}

.inner_modal {
    position: relative;
    width: 700px;
    margin: auto;
    padding: 30px;
    background-color: #17171a;
}

#zero {
    display: none;
}

.close {
    position: absolute;
    top: 5px;
    right: 10px;
    padding: 5px;
    font-size: 22px;
    color: #ffa200;
    cursor: pointer;
}
</code></pre></li>
<li><p><a href="http://m.jb51.net/css/68810.html" target="_blank" rel="external">流体布局中多列等高实现方法</a></p>

<p>高度相等列在web页面设计中永远是一个网页设计师的需求。如果所有列都有相同的背景色，高度相等还是不相等都是无关紧要的，因为只要在这些列的父元素中设置一个背景色就可以了。但是，如果一个或多个列需要单独设置自己的背景色，那么他的视觉完整性的设计就显得非常重要了。如果一个设计是固定宽度，那么实现多列等高效果是相当的容易。最好的技术是使用<a href="http://blog.csdn.net/kimylrong/article/details/7667384" target="_blank" rel="external">Faux Column技术</a>。只要制作一张合适的背景图片，在你多列的父元素中进行垂直铺放，从而达到一个假象，也就是假的多列等高布局效果。</p>

<pre><code>&lt;div id="container"&gt;
    &lt;div id="content"&gt;
        ...
    &lt;/div&gt;
    &lt;div id="sidebar"&gt;
        ...
    &lt;/div&gt;
&lt;/div&gt;

#container {
    width: 980px;
    margin: 0 auto;
    background: url("img/green.png") repeat-y;
    overflow: auto;
}
#content {
    width: 640px;
    float: left;
    background: #FFF;
}
#sidebar {
    width: 340px;
    float: right;
    background: #009040;
}
</code></pre>

<p>但是在流体布局中要使用CSS实现多列等高的设计就不是那么容易的事情，因为我们没有办法在使用背景图片来实现多列等高的假象了。但是，也还是有很多方法可以实现流体布局中多列等高的视觉效果哒~</p>

<ol>
<li><p>给容器div使用单独的背景色</p>

<pre><code> &lt;div id="container3"&gt;
     &lt;div id="container2"&gt;
         &lt;div id="container1"&gt;
             &lt;div id="col1"&gt;Column 1&lt;/div&gt;
             &lt;div id="col2"&gt;Column 2&lt;/div&gt;
             &lt;div id="col3"&gt;Column 3&lt;/div&gt;
         &lt;/div&gt;
     &lt;/div&gt;
 &lt;/div&gt;
 &lt;style&gt;
     #container3 {
         float: left;
         width: 100%;
         background: green;
         overflow: hidden;
         position: relative;
     }
     #container2 {
         float: left;
         width: 100%;
         background: yellow;
         position: relative;
         right: 30%; /*大小等于col3的宽度*/
     }
     #container1 {
         float: left;
         width: 100%;
         background: orange;
         position: relative;
         right: 40%; /*大小等于col2的宽度*/
     }
     #col1 {
         float: left;
         width: 30%;
         position: relative;
         left: 70%;
         overflow: hidden;
     }
     #col2 {
         float: left;
         width: 40%;
         position: relative;
         left: 70%;
         overflow: hidden;
     }
     #col3 {
         float: left;
         width: 30%;
         position: relative;
         left: 70%;
         overflow: hidden;
     }
 &lt;/style&gt;
</code></pre>

<p> 这种方法的优点是不需要借助其他东西，包括javascript、背景图等，使用纯HTML+CSS实现的等高多列布局，并且能够兼容所有浏览器，且易扩展。缺点是标签较多，理解起来有难度。</p></li>
<li><p>padding补偿法实现带边框多列等高</p>

<pre><code> &lt;style&gt;
     .wrapper {
         width: 960px;
         margin: 0 auto;
     }
     .container {
         position: relative;
         overflow: hidden;
         zoom: 1;
     }
     .col1 {
         float: left;
         width: 728px;
         padding-bottom: 32767px;
         margin-bottom: -32767px;
         border: #F36 1px solid;
         background: #AFAFAF;
     }
     .col2 {
         float: right;
         width: 208px;
         padding-bottom: 32767px;
         margin-bottom: -32767px;
         border: #F36 1px solid;
         background: #6F6F6F;
     }
     .colBottom1 {
         position: absolute;
         bottom: 0;
         left: 0px;
         height: 1px;
         width: 730px;
         background: #F36;
     }
     .colBottom2 {
         position: absolute;
         bottom: 0;
         right: 0px;
         height: 1px;
         width: 210px;
         background: #F36;
     }
 &lt;/style&gt;
 &lt;div class="wrapper"&gt;
     &lt;div class="container"&gt;
         &lt;div class="col1"&gt;
             Column 1：当页面中存在大量元素，而且每一个都要一次或多次绑定事件处理器时，每绑定一个事件处理器都是有代价的，这种情况会随着dom元素的增多而严重影响页面性能。事件代理机制是基于事件逐层冒泡并能被父级元素捕获的原理，使用事件代理机制，仅需要给外层元素绑定一个处理器，就可以处理在其子元素上触发的所有事件。当页面中存在大量元素，而且每一个都要一次或多次绑定事件处理器时，每绑定一个事件处理器都是有代价的，这种情况会随着dom元素的增多而严重影响页面性能。事件代理机制是基于事件逐层冒泡并能被父级元素捕获的原理，使用事件代理机制，仅需要给外层元素绑定一个处理器，就可以处理在其子元素上触发的所有事件。
             &lt;div class="colBottom1"&gt;&lt;/div&gt;
         &lt;/div&gt;
         &lt;div class="col2"&gt;
             Column 2：当页面中存在大量元素，而且每一个都要一次或多次绑定事件处理器时，每绑定一个事件处理器都是有代价的，这种情况会随着dom元素的增多而严重影响页面性能。事件代理机制是基于事件逐层冒泡并能被父级元素捕获的原理，使用事件代理机制，仅需要给外层元素绑定一个处理器，就可以处理在其子元素上触发的所有事件。
             &lt;div class="colBottom2"&gt;&lt;/div&gt;
         &lt;/div&gt;
     &lt;/div&gt;
 &lt;/div&gt;
</code></pre></li>
<li><p>javascript大法</p>

<pre><code> function matchColumns(classname){
     var divs, contDivs, maxHeight, divHeight, d;
     divs = document.getElementsByTagName("div");
     contDivs = [];
     maxHeight = 0;
     for(var i = 0, len = divs.length; i &lt; len; ++i){
         if(new RegExp("\\b"+classname+"\\b").test(divs[i].className)){
             d = divs[i];
             contDivs[contDivs.length] = d;
             if(d.offsetHeight){
                 divHeight = d.offsetHeight;
             }
             else if(d.style.pixelHeight){
                 divHeight = d.style.pixelHeight;
             }
             maxHeight = Math.max(maxHeight, divHeight);
         }
     }
     for(var i = 0, len = contDivs.length; i &lt; len; ++i){
         contDivs[i].style.height = maxHeight;
     }
 }
 window.onload = function(){
     if(document.getElementsByTagName){
         matchColumns('column');
     }
 }
</code></pre></li>
</ol>
</li>
<li><p><strong>文本溢出显示...</strong></p>

<ul>
<li><p>单行文本</p>

<pre><code>  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
</code></pre></li>
<li><p>多行文本: line-clamp</p>

<p>  <a href="http://www.css88.com/archives/tag/line-clamp" target="_blank" rel="external">多行文本溢出显示...</a></p>

<pre><code>  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
</code></pre></li>
</ul>
</li>
<li><p><a href="http://www.webhek.com/css-100-percent-height" target="_blank" rel="external">如何让height:100%起作用</a></p>

<p>根据W3C的规范，<strong>百分比的高度在设定时需要根据这个元素的父元素容器的高度去计算</strong>。当给元素设置宽度width:100%时元素的宽度会立刻扩展到窗口的整个横向宽度，但是当给一个div添加height:100%的css属性时，元素的高度并不能占满整个空间。这是因为，web浏览器在计算有效宽度时会考虑浏览器窗口的打开宽度，如果不给宽度设定任何缺省值，那浏览器会自动将页面内容平铺填满整个横向宽度，但是高度的计算方式完全不一样。事实上，浏览器根本不计算内容的高度，除非内容超出了视窗范围，导致滚动条的出现，或者给页面设置一个绝对宽度，否则，浏览器就会简单的让内容往下堆砌，页面的高度根本就无需考虑。因为页面没有缺省的高度值，所以，当你让一个元素的高度设定为百分比高度时，无法根据获取父元素的高度，也就无法计算自己的高度。换句话说，父元素的高度只是一个缺省值：height: auto;当你要求浏览器根据这一一个缺省值计算百分比高度时，只能得到undefined的结果，也就是一个null值，浏览器根本不会对这个值有任何反应。</p>

<p>所以如果想让元素的height:100%起作用，就要对他所有的祖先元素设置height:100%</p>

<p>高度自适应：绝对定位+top+bottom:0/Ie6：html:padding-top</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;高度自适应&lt;/title&gt;
    &lt;style&gt;
        html, body {
            height: 100%;
        }
        body, div {
            margin: 0;
            padding: 0;
            color: #f00;
        }
        .top {
            background: #36c;
            height: 100px;
        }
        .main {
            background: #f90;
            position: absolute;
            width: 100%;
            top: 100px;
            bottom: 0;
            overflow: auto;
        }
        /*IE6中，html的增加了padding-top后，整个html元素的高度还是保持不变，即浏览器窗口的高度，变化的是body的高度减小了，用来抵消html的padding-top.而绝对定位的元素最终是参照html元素的。*/
        * html {
            padding-top: 100px;
        }
        * html .top {
            background: #36c;
            height: 100px;
            position: absolute;
            top: 0;
            width: 100%;
        }
        * html .main {
            background: #f90;
            position: static;
            height: 100%;
        } 
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="top"&gt;我是顶层nav，高度固定&lt;/div&gt;
    &lt;div class="main"&gt;我是main，高度随浏览器视区大小变化而变化&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></li>
<li><p><a href="http://www.zhangxinxu.com/wordpress/2011/03/css-css3-unit-units/" target="_blank" rel="external">CSS的一些单位</a></p></li>
<li><p>资源汇总</p>

<ul>
<li><a href="http://www.wzsky.net/html/Website/Experience/118822.html" target="_blank" rel="external">css制作面包屑导航</a></li>
<li><a href="http://top.jobbole.com/5394" target="_blank" rel="external">css绘制多国国旗</a></li>
<li><a href="http://www.uisdc.com/20-registered-and-login-psd" target="_blank" rel="external">20个注册登录界面psd</a></li>
</ul>
</li>
</ol>


<h3>Javascript--定义行为</h3>

<ol>
<li><p><em>事件代理or事件委托</em></p>

<p> 当页面中存在大量元素，而且每一个都要一次或多次绑定事件处理器时，每绑定一个事件处理器都是有代价的，这种情况会随着dom元素的增多而严重影响页面性能。</p>

<p> 事件代理机制是基于事件逐层冒泡并能被父级元素捕获的原理，使用事件代理机制，仅需要给外层元素绑定一个处理器，就可以处理在其子元素上触发的所有事件。</p>

<pre><code> &lt;ul id="nav"&gt;   
     &lt;li&gt;&lt;a href=""&gt;&lt;/a&gt;&lt;/li&gt;    
     &lt;li&gt;&lt;a href=""&gt;&lt;/a&gt;&lt;/li&gt;    
     &lt;li&gt;&lt;a href=""&gt;&lt;/a&gt;&lt;/li&gt;    
     &lt;li&gt;&lt;a href=""&gt;&lt;/a&gt;&lt;/li&gt;    
     &lt;li&gt;&lt;a href=""&gt;&lt;/a&gt;&lt;/li&gt;    
 &lt;/ul&gt;

 &lt;script&gt;

     window.onload = function(){ 
         var nav = document.getElementById("nav");
         /*var links = nav.getElementsByTagName("a");
         for(var i=0, l=links.length; i &lt; l; i++){
             links[i].onclick =  function(){
                 alert(this.innerHTML);
                 return false;
             }   
         }*/

         // 利用了dom事件冒泡特性   
         nav.onclick = function(){   
             var e = arguments[0] || window.event, target = e.srcElement ? e.srcElement : e.target；                    alert(target.innerHTML);
             return false;
         }

         function addListener(element, event, function){
             if(element.addEventListener){//FF个小婊砸
                 element.addEventListener(event, function, false);//是否使用捕获
             }
             else{
                 element.attachEvent("on"+event, function);
             }
         }   
     }
 &lt;/script&gt;
</code></pre></li>
<li><p>ES5和ES6：ES6中新增元素<em>越来越接近python</em></p>

<ul>
<li><p>箭头操作符</p>

<pre><code>  array.forEach(fucntion(v, i, a){
      console.log(v);
  });
  =&gt;
  array.forEach(v =&gt; console.log(v));
</code></pre></li>
<li><p>class关键字</p></li>
<li>增强的对象字面量</li>
<li>字符串模板：`${num}`</li>
<li>解构：返回值可以为数组</li>
<li><p>参数可以省略，可以设置默认值</p>

<pre><code>  function add(...x){
      return x.reduce((m, n) =&gt; m+n);
  };  
</code></pre></li>
</ul>
</li>
<li><p>Javascript中<strong>this</strong>的工作机制-函数在哪里调用this指向哪里</p>

<p> javascript有一套不同于其他语言的对this的处理机制，在五种不同的情况下，this指向的各不相同</p>

<ol>
<li>全局范围内this指向全局对象，默认是window</li>
<li>函数调用时，this指向全局对象</li>
<li>方法调用时，this指向的是调用此方法的对象</li>
<li>调用构造函数时，在函数内部，this指向新创建的对象</li>
<li><p>显示设置this<strong>使用Function.prototype的call和apply时，函数内的this会被显式设置为函数调用的第一个参数</strong></p>

<pre><code> var n = 0;
 function output(){
     alert(this.n);
 }
 var bar = {};
 bar.n = 1;
 bar.s = output;
 bar.s.apply();//0
 bar.s.call(bar, arg1, arg2, ...);
 bar.s.apply(bar, [arguments]); // 1
</code></pre></li>
</ol>
</li>
<li><p>javascript中的原型<strong><em>继承</em></strong></p>

<p> 工厂模式 构造函数 原型方法</p>

<p> C++继承public private protect，多态是基类和子类拥有相同的函数，这就涉及到一个概念--虚函数。delete基类指针时，若基类析构函数不是虚函数，那么只把基类部分的内存进行析构，而不会析构子类，从而导致内存泄露。如果将基类的析构函数改成虚函数，就可以避免这种情况，因为虚函数是后绑定的，析构函数将基类析构函数用实际对象的一组析构函数替换掉，先执行子类析构函数再执行父类虚函数。但是如果delete的是子类指针，那么在调用子类析构函数后会自动调用父类的析构函数。虚函数是为了重载和多态的需要，在基类中有定义，即便定义为空，子类中可以重写，纯虚函数是基类中没有定义，必须在子类中实现，相当于一个接口，拥有纯虚函数的类叫做虚基类，不能直接生成对象。</p>

<p> <strong>原型链</strong>:</p>

<ul>
<li>每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。</li>
<li>hasOwnProperty：是用来判断一个对象是否有你给出名称的属性或对象。不过需要注意的是，此方法无法检查该对象的原型链中是否具有该属性，该属性必须是对象本身的一个成员，in可以判断一个对象和他的原型链是否有属性或对象。isPrototypeOf是用来判断要检查其原型链的对象是否存在于指定对象实例中，是则返回true，否则返回false</li>
<li><p>属性查找：当查找一个对象的属性时，Javascript会向上遍历原型链，直到找到给定名称的属性为止，到查找到达原型链的顶部，也就是Object.prototype时，仍然没有找到时，会返回undefined</p>

<pre><code>  A.prototype.__proto__ = B.prototype;

  function Person(){} //空的构造函数
  Person.prototype = {
      init: function(name){
          this.name = name;
      },
      getName: function(){
          return this.name;
      },
      call: function(){
          alert("I am a person");
      }
  };
  function Employee(){}
  Employee.prototype = new Person();
  Employee.prototype.constructor = Employee;//显示指定constructor可以防止prototype改写带来的问题
  Employee.prototype.init = function(name, employeeID){
      this.name = name;
      this.employeeID = employeeID;
  };
  Employee.prototype.getEmployeeID = function(){
      return this.employeeID;
  };
  Employee.prototype.call =function(){
      alert("I am an employee");
  }

  function Person(){}//定义一个函数
  var person = Person();//执行函数并将返回值赋值给person，如果Person是一个构造器的话，新的对象不会被创建，this将绑定到全局对象上
  var person = new Person();//使用构造函数Person构造一个实例对象person

  //属性查找展示 原型链
  function foo() {
      this.add = function (x, y) {
          return x + y;
      }
  }

  foo.prototype.add = function (x, y) {
      return x + y + 10;
  }

  Object.prototype.subtract = function (x, y) {
      return x - y;
  }

  var f = new foo();
  alert(f.add(1, 2)); //结果是3，而不是13
  alert(f.subtract(1, 2)); //结果是-1

  定义"类"  Ob

  两个实例化的对象 obj1,   obj2

  obj1.a = 1;

  console.log (obj1.a);

  console.log (obj2.a);

  Ob.prototype.a = 2;

  console.log (obj1.a);

  console.log (obj2.a);



  //答    1, undefined, 1, 2

  //解释   实例变量    原型中的变量什么的，原型链搜索

  ES6 class extends constructor

  var Animal = class Animal {
      constructor(name) {
          this.name = name;
      }

      speak() {
          console.log(this.name + 'speaks');
      }
  }

  var Dog = class Dog extends Animal {
      speak() {
          console.log(this.name + 'barks');
      }
  } 
</code></pre></li>
</ul>
</li>
<li><p>javascript<strong><em>数据类型</em></strong></p>

<ul>
<li>null 表示没有对象，即该处不应有值，典型的用法是作为函数的参数或对象原型链的终点</li>
<li>undefined 表示缺少值，此处应该有值，只是未定义，典型的用法是

<ol>
<li> 变量已经被声明，但是没有赋值</li>
<li> 调用函数时，应该提供的参数没有被提供</li>
<li> 对象没有赋值的属性</li>
<li> 函数没有返回值时，默认返回undefined</li>
</ol>
</li>
<li>boolean</li>
<li><p>number--<a href="http://www.cnblogs.com/gushen/archive/2012/11/20/2778324.html" target="_blank" rel="external">js中toFixed解决办法</a></p>

<pre><code>  toFixed在ie6下存在bug
  Number.prototype.toFixed = function(s) {
      return (parseInt(this * Math.pow(10, s) + 0.5) / Math.pow(10, s)).toString();
  }
</code></pre></li>
<li><p>string</p></li>
<li>array/symbol</li>
<li>object

<ol>
<li> var obj = {}</li>
<li> var obj = new Object();</li>
<li><p> var obj = Object.create(Object.prototype);</p>

<pre><code>  使用new关键字调用构造函数时：
  1. 会首先创建一个空对象，并且this变量引用该对象，同时还继承了函数的原型；
  2. 属性和方法被加入到this引用的对象中；
  3. 新创建的对象由this所引用，并且最后隐式返回this。
</code></pre></li>
</ol>
</li>
</ul>
</li>
<li><p>javascript<strong>反射</strong></p>

<p> 反射定义：计算机程序在运行时可以访问、修改和检测他本身状态或行为的一种能力=》能够观察并修改自己的行为。对于javascript而言，简单来说，就是对类的成员进行修改等操作。javascript可以通过for(...in...)来实现反射。</p>

<p> javascript中没有专门的机制来实现类的继承，但可以通过赋值一个类的prototype到另外一个类来实现继承。但是，这种方式并非严格的继承，两个类是同一prototype的引用，重写一个类的成员或方法会影响另一个。可以使用反射机制来继承，利用for(...in...)语句枚举出所有的基类prototype的成员，并将其赋值给prototype对象。进一步，可以为每个类添加一个共有的方法用来实现类的继承。</p>

<pre><code> function.prototype.inherit = function(baseClass){
     for(var p in baseClass.prototype){
         this.prototype[p] = baseClass.prototype[p];
     }
 }
</code></pre>

<p> 可以看出，所谓的反射机制，从简单方面来讲，就是对类中成员进行枚举、修改等操作的能力。如果存在一种机制，在不知道某一个类中到底有什么函数，或者成员变量的情况下就可以对其操作（例如，javascript可以对类成员进行枚举），这种机制就可以称为反射。在实现继承机制时，只需要通过反射机制逐一复制，然后再修改需要覆盖的成员，就可以达到继承的效果。这也是反射机制的一个应用。</p></li>
<li><p><strong>javascript闭包</strong></p></li>
<li><p>javascript模块化管理</p>

<ol>
<li><p>为什么需要模块化</p>

<ol>
<li>恼人的命名冲突</li>
<li>繁琐的文件依赖</li>
</ol>
</li>
<li><p>模块化编程</p>

<ul>
<li>定义封装的模块+定义新模块对其他模块的依赖+对其他模块的引入支持</li>
<li><p>commonjs：require()引入外部模块，exports对象用于导出当前模块的方法或变量，module对象表示模块本身，是一种<em>同步</em>加载方式，不适合浏览器环境→nodejs</p>

<pre><code>  var math = require("math");
  math.add(2, 3);//math模块加载完毕才能执行
</code></pre></li>
<li><p>AMD：<em>异步</em>模块定义，自由变量/全局变量define函数，define(id?,dependencies?,factory)→requirejs，<em>依赖前置or依赖注入？！</em></p>

<pre><code>  define("alpha", ["require", "exports", "beta"], funtion(require, exports, beta){
      exports.verb = function(){
          //return beta.verb();
          return require("beta").verb();
      };
  });
</code></pre></li>
<li><p>CMD：define(function(<strong>require,exports,module</strong>){...})→seajs，<em>依赖就近</em></p>

<pre><code>  define(id?, reps?, factory)
                         |
              require, exports, module
  define(funtion(require, exports, module){
      var verb = require("verb");
      module.eports.verb = function(){
          //return beta.verb();
          return require("beta").verb();
      }
  });
</code></pre>

<p>  coolie//nodejs部分一个模块化开发工具</p></li>
</ul>
</li>
<li><p>seajs--为前端开发提供简单、极致的模块化开发体验的一个<strong>模块加载器</strong></p>

<ol>
<li>通过exports暴露接口，这意味着不需要命名空间了，更不需要全局变量，这是一种彻底的命名冲突解决方案</li>
<li>通过require引入依赖，可以让依赖内置，开发者只需要关心当前模块的依赖，其他事情seajs都会自动处理好，对模块开发者来说，这是一种很好的关注度分离，能让程序媛更多地享受编码的乐趣</li>
<li>模块的版本管理，通过别名等配置，配合构建工具，可以比较轻松地实现模块的版本管理</li>
<li>提高可维护性，模块化可以让每个文件的职责单一，非常有利于代码的维护，seajs还提供了nocache、debug等插件，拥有在线调试等功能，能比较明显地提升效率。</li>
<li>前端性能优化，seaj通过异步加载模块，这对页面性能非常有益，seajs还提供了combo、flush等插件，配合服务端，可以很好地对页面性能进行调优</li>
<li>跨环境共享模块，CMD模块定义规范与nodejs的模块规范费仓相近，通过seajs的nodejs版本，可以很方便地实现模块的跨服务器和浏览器共享</li>
</ol>
</li>
</ol>
</li>
<li><p>变量声明提升，<em>定义还在原来的地方</em>，函数声明提前，变量声明提前，但是函数优先级高，同名时意义为函数-<strong>javascript中变量的作用域由函数决定</strong></p>

<pre><code> function test(){
     console.log(a);         //undefined
     console.log(foo());     //2
     var a = 1;
     function foo(){
         return 2;
     }
 }
</code></pre></li>
<li><p>window.onload和$(document).ready区别</p>

<p>ready表示文档的dom已经加载完毕，但不包括图片、视频等资源，而onload事件是DOM树创建完毕并且网页所依赖的资源都加载完成后发生，ready发生在onload之前；onload需要页面上所有的资源都加载上之后执行，而ready是DOM文档树已经解析完成时，说ready比onload快最显著的是比如一个页面上有一个很大的图片，加载要好久，onload只有在图片加载完成之后执行，而ready不必等图片加载完成。</p></li>
<li><p><strong>javascript同源策略</strong></p>

<p>同源策略<em>SOP</em>限制了一个源中加载文本或脚本与来自其他源中资源的交互方式。同源策略出于<strong>安全</strong>考虑，不允许源A的脚本读取源B的资源内容，但却允许执行源B的资源。</p>

<p>来自源点 A 的 Web 页面可以：</p>

<ul>
<li>从源点 B 获取脚本、CSS 样式表或图像</li>
<li>包含一个指向源点 B 中页面的 iframe/frame</li>
<li>使用 HTML 元素的 src 属性（比如iframe 或img）将信息发送到源点 B 。</li>
</ul>


<p>来自源点 A 的 Web 页面不可以：</p>

<ul>
<li>对源点 B 进行 Ajax 调用</li>
<li>读取或操纵 iframe/frame 中指向页面 B 的内容</li>
</ul>


<p>要求：协议相同、域名相同、端口相同</p>

<p><em>跨域通信</em>：</p>

<ul>
<li>img、script、link、iframe（慎用），使用CDN库</li>
<li>请求json数据/jsonp</li>
<li>window.postMessage</li>
<li>内部服务器代理</li>
<li>HTML5规范重点CORS功能： Access-Control-Allow-Origin:</li>
<li><a href="https://www.ibm.com/developerworks/cn/web/wa-crossdomaincomm/" target="_blank" rel="external">利用客户端解决方案改进跨域通信</a>：</li>
</ul>


<p>mashup 是一种将不同供应商的数据或组件集成起来，使之更加有用或更用户化的 Web 应用程序</p>

<pre><code>1. 跨子域解决方案：document.domain
    &lt;script&gt;
        document.domain = "css88.com";//document.write(document.domain)
        var createAjaxIframe={
            appIframe: function(iframeId, iframeSrc){
                var iframe = document.createElement("iframe");
                iframe.src = iframeSrc;//"http://css88.com/demo/domain/iframe.html"
                iframe.id = iframeId;
                iframe.style.display = "none";
                if (iframe.attachEvent) {
                    iframe.attachEvent("onload", function(){
                        createAjaxIframe.domainAjax(iframeId);
                    });
                }else {
                    iframe.onload = function(){
                        createAjaxIframe.domainAjax(iframeId);
                    };
                }
                document.body.appendChild(iframe);
            },
            domainAjax: function(iframeId){
                var iframeDom = document.getElementById(iframeId).contentWindow.$;//获得iframe的window对象
                iframeDom.getJSON("http://css88.com/demo/iframe-domain/city.html", function(date){
                    var cityOption = "";
                    for (i = 0; i &lt; date.length; i++) {
                        cityOption += date[i].c_name + "--" + date[i].c_value + "&lt;br /&gt;"
                    }
                    $("#test").html(cityOption);
                });
            }   
        };
        createAjaxIframe.appIframe("iframe","http://css88.com/demo/iframe-domain/iframe.html");
    &lt;/script&gt;
2. URL.hash解决方案：URL的任何更改都会导致加载新的页面。唯一的例外是 hash 值的变化。任何 URL 的 hash 更改都不会导致页面刷新。许多 Web 2.0 网站中都已经开始广泛使用 Hash，以标记部分刷新页面时的每一个步骤。在跨域通信中，hash 是一笔宝贵的资产。虽然在获取对方 hash 值方面有一些限制，但来自不同源点的文件可以设置对方的 URL，包括 hash 值。文档相互之间可以使用 hash 传送信息。
3. cross-fragment技术，使用了iframe。当 A 想要与 iframe B 进行通信时，会先在其自身中创建一个 iframe。这个 iframe 指向与 B 位于同一域中的 “代理” C。代理 URL 中包含参数、数据以及 B 的框架标识符。当 C 加载信息时，它会从 A 中获取请求和数据并调用 B 中相应的方法。由于 B 和 C 在相同的域中，所以可以通过另一个窗口的处理程序直接调用对方的方法。A 可以成功地向 B 发送信息，B 也可以用同样的方式进行响应。
4. postMessage方案

        http://www.otherapp.com/index.html
        function postMessage(msg){
             var targetWindow = parent.window;
              targetWindow.postMessage(msg,"*");
        }
        function handleReceive(msg){
         var object = dojo.fromJson(msg);
         if(object.status == “ok”){
            //continue to do other things
            ……
         }else{
            //retry sending msg
            ……
         }
        }
        window.addEventListener("message", handleReceive, false);
        window.onLoad = function(){
            postMessage("already loaded");
        }

        http://www.myapp.com/index.html
        function handleReceive(event){ 
            if(event.origin != "http://www.otherapp.com")
                return; 
             //process data
             ……
             var otherAppFrame = document.getElementById(“otherApp”) 
             otherAppFrame.postMessage(“{status:’ok’}”,”http://www.otherapp.com”);
        }
        window.addEventListener("message", handleReceive, false);
</code></pre></li>
<li><p>重写javascript内置代码</p>

<p>利用arguments对象（伪数组）可以实现重载，利用arguments.length可以获取函数的参数个数，typeof判断类型，Object.prototype.toString.call()</p>

<pre><code>Array.prototype.duplicator = Array.prototype.duplicator || function(){
    return this.concat(this);
}

//函数内部的特殊参数对象arguments，添加前缀(app)，注意的是arguments是一个伪数组，需要转化成标准数组后才能使用unshift方法
var log = function(){
    var args = Array.prototype.slice.call(arguments);
    args.unshift('(app)');
    console.log.apply(console, args);
}

function stringconcat(){
    var result = [];
    stringconcat.merge.call(null, result, arguments);
    return result.join("+");
}
stringconcat.prefix = function(){
    var _arguments = [], _this = this;
    _this.merge.call(null, _arguments, arguments);
    return function(){
        var _args = _arguments.slice(0);//选择全部
        _this.merge.call(null, _args, arguments);
        return _this.apply(null, _args);
    };
};
stringconcat.merge = function(array, arrayLike){
    var i = 0, len = 0;
    for(i = 0, len = arrayLike.length; i &lt; len; i++){
        array.push(arrayLike[i]);
    }
}

function repeat(func, times, wait){
    function repeatImpl(){
        var handler, _arguments = arguments, i = 0;
        handler = setInterval(function(){
            i = i+1;
            if(i &gt; times){
                clearInterval(handler);
                return;
            }
            func.apply(null, _arguments);
        }, wait);
    }
    return repeatImpl;
}
var repeatFun = repeat(alert, 4, 3000);
repeatFun("helloword");
</code></pre></li>
<li><p>'use strict'</p>

<p>使javascript代码以严格模式运行，其设立目的为：</p>

<ol>
<li>消除javascript语法的不合理不严谨之处，减少一些怪异行为</li>
<li>消除代码允许的不安全之处，保证代码运行的安全</li>
<li>提高编译器效率，增加运行速度</li>
<li>为未来新版本的javascript做铺垫</li>
</ol>
</li>
<li><p><strong>AJAX</strong></p>

<ul>
<li><p>工作原理</p>

<p>  异步javascript和xml，是一种创建交互式网页应用的网页开发技术。其工作原理相当于在用户和服务器之间加了一个中间ajax引擎，使用户操作和服务器响应异步化。通过<strong><em>XMLHttpRequest</em></strong>或者<strong>ACtiveXObject</strong>对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作dom从而更新页面。</p>

<p>  ajax好处是<strong>无刷新更新数据、异步与服务器通信、前后端负载平衡、数据与呈现分离</strong>，结合angularjs。<a href="http://m.baidu.com/from=1099b/bd_page_type=1/ssid=0/uid=0/pu=usm%400%2Csz%401321_2001%2Cta%40utouch_1_8.1_3_600/baiduid=93CE25ED7C3279A8595C592724F2DB72/w=0_10_ajax%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/t=wap/l=3/tc?ref=www_utouch&amp;lid=7784803104100688478&amp;order=1&amp;vit=osres&amp;tj=www_normal_1_0_10_title&amp;m=8&amp;srd=1&amp;dict=20&amp;sec=2078&amp;di=636f8a3d787881d8&amp;bdenc=1&amp;nsrc=IlPT2AEptyoA_yixCFOxXnANedT62v3IEQGG_ytK1DK6mlrte4viZQRAMT06TXaN1FXsx7P0sqdUgiPzRiBzzBAxrqxpsH9hbX8fgPq3ghCLHqIOfgBjOgaSFiowz3C" target="_blank" rel="external">参考</a></p></li>
<li><p>用法</p>

<pre><code>  var xmlhttp = new window.XMLHttpRequest ? XMLHttpRequest() : ActiveXObject("Microsoft.XMLHTTP");
  xmlhtp.onreadystatechange = function(){
      if(xmlhttp.readystate == 4 &amp;&amp; xmlhttp.status == 200){
          //0 请求未初始化
          //1 服务器连接已建立
          //2 请求已接收
          //3 请求处理中
          //4 请求已完成，且响应已就绪
          //readyState 有五种取值：
          //“uninitialized”：默认状态
          //“loading”：下载开始
          //“loaded”：下载完成
          //“interactive”：下载完成但尚不可用
          //“complete”：所有数据已经准备好
      }
  };
  //get方法
  xmlhttp.open(“GET”, "url", true);
  xmlhttp.send();
  //post方法
  xmlhttp.open(“POST”, "url", true);
  xmlhttp.sendRequestHeader("Content-type", "application/x-www-form-urlencode");
  xmlhttp.send("param1=value1&amp;param2=value2")

  // 从服务端获取当前的时间
  getCurrentTime: function (callback) {
    var xmlhttp = new XMLHttpRequest;
    xmlhttp.onreadystatechange = function () {
      if (xmlhttp.readyState != 4) {
        return;
      }
      var now = new Date(xmlhttp.getResponseHeader('date'));
      if (!now) {
        now = new Date;
      }
      xmlhttp.onreadystatechange = null;
      callback(now);
    };
    xmlhttp.open("HEAD", location.href, true);
    xmlhttp.send(null);
  }
</code></pre></li>
</ul>
</li>
<li><p><strong>JSONP</strong></p>

<p>可执行的javascript数据，利用了script的跨域能力，通过<em>插入script和调用回调函数</em>来实现跨域通信，可以被调用并使用动态脚本注入技术插入到任何网站，解决了ajax的跨域问题</p>

<p>jsonp是一种简单高效的跨域方式，html中的script标签可以加载并执行其他域的js，于是我们可以通过script标记来动态加载其他域的脚本。jsonp易于实现，但也存在安全隐患，若第三方脚本随意执行，那么他就可以任意修改页面内容，获得敏感数据。但在信任的双方传递数据，还是非常合适的。</p>

<pre><code>$("#getJsonpByJquery").click(function () {
    $.ajax({
        url: 'http://localhost:2701/home/somejsonp',
        dataType: "jsonp",
        jsonp: "callback",
        success: function (data) { console.log(data); } 
    });
});
//原生JS
&lt;button id="btn"&gt;click&lt;/button&gt;
&lt;script type="text/javascript"&gt;
    function $(str){
        return document.getElementById(str);
    }
    function CreateScript(src) {
        var Scrip=document.createElement('script');
        Scrip.src=src;
        document.body.appendChild(Scrip);
    }
    function jsonpcallback(json) {
        console.log(json);//Object { email="中国", email2="中国222"}
    }
    $('#btn').onclick=function(){
      CreateScript("http://localhost:51335/somejson?callback=jsonpcallback")    
    };
&lt;/script&gt;
</code></pre>

<p>json数据是javascript对象表示法，与javascript中对象很类似，但是json中key必须使用双引号，value只能取数字、字符串、布尔值、数组、对象和null</p>

<pre><code>var jsonStr = '{"name": "Sally", "age": 18}';
eval('('+jsonStr+')');
JSON.parse(jsonStr, function(key, value){});
var obj = {name: "Sally", age: 18};
JSON.stringify(obj, function(key, value){});
</code></pre></li>
<li><p>小知识</p>

<ul>
<li><strong>var a = b = 5;//a是局部变量，b是全局变量</strong></li>
<li>javascript和css属性对照

<ul>
<li>-webkit-column-count webkitColumnCount/-moz-column-count MozColumnCount/-ms-transform msTransform</li>
<li>不变：border clear margin padding background color display font</li>
<li>不一致：float→floatStyle</li>
<li>驼峰：含有-的</li>
</ul>
</li>
<li>href="#"和href="javascript: void(0)"区别：<strong>前者是位置信息，后者是一个死链</strong></li>
<li>focus和focusin

<ul>
<li>前者不冒泡，后者冒泡</li>
<li>前者兼容性好，后者除Firefox外都很好</li>
<li>可获得焦点的元素：window，链接被点击或键盘操作，表单空间被点击或键盘操作，设置<em>tabindex</em>属性的元素被点击或键盘操作</li>
</ul>
</li>
<li><p>===和==区别</p>

<pre><code>  ===比较过程
  1. 类型 不同 false
  2. 值都是null或者undefined true
  3. 都是bool类型true或者false true
  4. 有一个是NaN false
  5. 都是number且值相等 -0=0 true
  6. 都是字符串，且相同位置包含相同的16位值 true 长度或者内容或者编码不同 false
  7. 指向相同对象、数组、函数 true

  ==比较过程
  1. 类型相同，转===比较
  2. null和undefined相等
  3. 数值和字符串转数字相等
  4. bool类型true-1 false-0
  5. 对象和数字/字符串比较，将对象转换为原始值用==继续比较
</code></pre></li>
<li><p>ToPrimitive</p>

<pre><code>  在javascript中，一共有2种数据类型：原始值和对象值，原始值又包括undefined，null，bool、number和string，其他所有都是对象值，包括array和function

  1. 如果输入值是原始值，则返回自身
  2. 调用对象转数字过程（undefined=&gt;NaN）
      1. valueOf 返回值作数字
      2. toString返回原始值，用结果作数字
      3. throw a TypeError
  3. 调用对象转字符串过程
      1. toSting 若返回原始值，则用结果作字符串
      2. 没有toSting或返回值不是原始值，调用valueOf方法
      3. throw a TypeError

  计算value1+value2时
  1. 执行ToPrimitive过程
  2. 任意为字符串，则两者都转换为字符串，否则为数字加
      &gt; []+[]
      &lt; ""
      &gt; []+{}
      &lt; "[object Object]"
      &gt; {}+[]
      &lt; 0
      &gt; {}+{}
      &lt; NaN //JavaScript引擎将第一个{}解释成了一个空的代码块并忽略了它.NaN其实是后面的表达式+{}计算的结果 (加号以及后面的{}).这里的加号并不是代表加法的二元运算符,而是一个一元运算符,作用是将它后面的操作数转换成数字,和Number()函数完全一样.
</code></pre></li>
<li><p>判断是否第一次点进<strong>isPostBack</strong></p></li>
<li><p>判断一个对象是否为数组</p>

<pre><code>  function isArray(arg){
      if(typeof arg === "object"){
          return Object.prototype.toString.call(arg) === "[Object Array]";
      }
      return false;
  }
</code></pre></li>
<li><p>判断一个对象是否为函数</p>

<pre><code>  function isFunction(arg){
      if(arg){
          if(typeof("/./") !== "function"){
              return typeof arg === "function";
          }
          else{
              return Object.prototype.toString.call(arg) === "[Object Function]";
          }
      }
      return false;
  }
</code></pre></li>
<li><p>getViewportSize</p>

<pre><code>  function getViewportSize(w){
      w = w | window;
      if("innerHeight" in w){//IE9及标准浏览器 pageXOffset
          return {
              width: w.innerWidth,
              height: w.innerHeight
          };
      }
      var d = w.document;
      if(document.compatMode === "CSS1Compat"){//IE8及以下浏览器在标准模式下
          return {
              width: d.documentElement.innerWidth,//scrollLeft
              height: d.documentElement.innerHeight
          };
      }
      return {//IE8及以下浏览器在怪异模式下
          width: d.body.innerWidth,
          height: d.body.innerHeight
      };
  }

  function viewport(){
      var e = window , a = 'inner';
      if ( !( 'innerWidth' in window ) ) {
          a = 'client';
          e = document.documentElement || document.body;
      }
      return { width : e[ a+'Width' ] , height : e[ a+'Height' ] }
  }
</code></pre></li>
<li>createElement(tagName)/createTextNode(text)包含文本的文本节点/createDocumentFragment()文档碎片节点</li>
<li>js的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Event" target="_blank" rel="external">event</a>对象</li>
</ul>
</li>
<li><p>DOM遍历</p>

<ul>
<li>获取父亲节点 parentNode/parentElement(IE)</li>
<li>获取子节点 childNodes/children(IE)</li>
<li>兄弟节点 previousSibling/nextSibling <em>nodeType(1.元素2.属性3.文本8.注释9.文档)</em></li>
</ul>
</li>
<li><p>Javascript异步IO</p>

<p>setTimeout/setInterval,ajax,<strong>web worker</strong></p>

<ol>
<li><p><em>web worker</em></p>

<p> 是html5提供的一个javascript多线程解决方案，其基本原理是在当前javascript主线程中，使用worker类加载一个javascript文件来开辟一个新的线程，起到互不阻塞执行的效果，并且提供主线程和新线程之间数据交换的接口：postmessage，onmessage。利用web worker我们可以在执行一些复杂的大量运算而不会影响页面的展示，并且不会弹出恶心的脚本正忙提示，但是web worker不支持跨域加载js，内部不能访问dom，不是每个浏览器都支持这个新特性。</p>

<pre><code> //worker.js
 var i=0;

 function timedCount(){
     i=i+1;
     postMessage(i);
     setTimeout("timedCount()",500);
 }
 timedCount();

 //web_worker.html
 &lt;!DOCTYPE html&gt;
 &lt;html&gt;
     &lt;head&gt;
         &lt;title&gt;Sallymew is great!&lt;/title&gt;
         &lt;meta http-equiv="Content-Type" content="text/html; charset=gb2312" /&gt;
         &lt;meta http-equiv="Content-Language" content="zh-cn" /&gt;
     &lt;/head&gt;
     &lt;body&gt;
         &lt;!--要死 为什么chrome不能正常执行啊！！！--&gt;
         &lt;p&gt;计数: &lt;output id="result"&gt;&lt;/output&gt;&lt;/p&gt;
         &lt;button onclick="startWorker()"&gt;开始 Worker&lt;/button&gt; 
         &lt;button onclick="stopWorker()"&gt;停止 Worker&lt;/button&gt;
         &lt;br /&gt;&lt;br /&gt;

         &lt;script&gt;
             var w;
             function startWorker(){
                 if(typeof(Worker) !== "undefined"){
                     if(typeof(w) == "undefined"){
                         w = new Worker("worker.js");
                     }
                     w.postMessage("hello");
                     w.onmessage = function (event) {
                         document.getElementById("result").innerHTML = event.data;
                     };
                 }
                 else{
                     document.getElementById("result").innerHTML="Sorry, your browser does not support Web Workers...";
                 }
             }

             function stopWorker(){ 
                 w.terminate();
             }
         &lt;/script&gt;
     &lt;/body&gt;
 &lt;/html&gt;
</code></pre></li>
</ol>
</li>
<li><p>javascript事件队列</p>

<pre><code>var QueueEnginer = funtion(){
    this.Queue = [];
}
QueueEnginer.prototype = {
    processTime: 20,
    add: function(fn, context, arrParam){
        this.Queue.push{
            fn: fn,
            context: context,
            param: arrParam
        }
    },
    start: function(){
        var that = this;
        setTimeout(function(){that.process();}, that.processTime);
    },
    process: function(){
        var queue = this.Queue.shift();
        if(!queue) return;
        queue.fn.apply(queue.context, queue.param);
        queue = null;//垃圾回收
        this.start;
    }
}
</code></pre></li>
<li><p>javascript垃圾回收机制</p>

<ul>
<li>变量生命周期</li>
<li>标记清除</li>
<li>引用计数</li>
</ul>
</li>
<li><p><strong>一些宽度值意义</strong></p>

<ul>
<li>offsetWidth: content+padding+border==getBoundingClientRect()</li>
<li>clientWidth: content+padding</li>
<li>scrollWidth: content+padding+溢出尺寸==就是真实的width</li>
</ul>
</li>
<li><p><strong>事件模型</strong></p>

<ul>
<li><p>DOM事件模型</p>

<ol>
<li> 首先它的事件模型中引入了传播过程：1）先由document向目标对象传播称之为：捕捉阶段；2）目标对象的事件处理程序运行，3）从目标对象向document起泡。Event.stopPropagation()可以停止传播，preventDefault()可以阻止事件的默认动作（想想以前的return false）。</li>
<li> 事件处理程序注册：EventTarget.addEventListener(String type,EventListener listener,boolean useCapure)。其中第三个参数决定<strong>注册程序在传播的哪个过程被调用</strong>，true:在捕捉阶段调用，false:在后两个阶段被调用</li>
</ol>
</li>
<li><p>IE事件模型</p>

<ol>
<li> 首先执目标元素的处理函数,然后向上传播（冒泡）到达document,ie中只能捕捉鼠标事件,而DOM2中可以捕捉所有的事件</li>
<li> Event对象不是事件处理程序的函数参数，而是window的全局变量</li>
<li> 事件注册函数:attachEvent( "eventType","handler") and detachEvent("eventType","handler" ),与dom2不同的是eventType有on前缀</li>
</ol>
</li>
<li><p>两者的区别是：IE没有捕捉阶段，只能捕捉鼠标事件，而DOM事件中所有事件都可以捕捉；event在IE中是window的全局对象，而在DOM中是第一个参数；target在IE中是event.SrcElement在DOM中是event.target；IE事件类型有on前缀，DOM中没有；事件注册函数参数不同</p></li>
</ul>
</li>
<li><p><strong>事件代理和事件绑定跨浏览器版</strong>利用了事件冒泡特性，避免了批量绑定事件，提高了网站的性能</p>

<ul>
<li>preventDefault()  阻止默认行为 →returnValue</li>
<li>stopPropagation() 阻止冒泡    →cancelBubble</li>
<li><p>return false      js阻止默认行为，jquery中阻止默认行为&amp;&amp;阻止冒泡</p></li>
<li><p>innerText FF不支持</p></li>
<li>textContent   W3C标准API（推荐） 文本内容   可以避免XSS攻击</li>
<li><p>innerHTML HTML内容</p>

<pre><code>  var EventUtil = {
      getEvent: function(event){
          return event || window.event;
      },
      getTarget: function(event){
          return event.target || event.srcElement;
      },
      on: function(elem, type, handler){
          if(elem.addEventListener){
              elem.addEventListener(type, handler, false);
              return handler;
          }else if(elem.attachEvent){
              fucntion wrapper(event){
                  return handler.call(elem, event);
              }
              elem.attachEvent("on" + type, wrapper);
              return wrapper;
          }
      },
      off: function(elem, type, handler){
          if(elem.removeEventListener){
              elem.removeEventListener(type, handler, false);
          }else if(elem.detachEvent){
              elem.detachEvent("on" + type, handler);
          }
      },
      preventDefault: function(event){
          if(event.preventDefault){
              event.preventDefault();
          }else if("returnValue" in event){
              event.returnValue = false;
          }
      },
      stopPropagation: function(event){
          if(event.stopPropagation){
              event.stopPropagation();
          }else if("cancelBubble" in event){
              event.cancelBubble = true;
          }
      }
  }
  var DOMUtil = {
      text: function(elem){
          if("textContent" in elem){
              return elem.textContent;
          }else if("innerText" in elem){
              return elem.innerText;
          }
      },
      prop: function(elem, propName){
          return elem.getAttribute(propName);
      }
  };
  var nav = document.getElementById("nav");
  EventUtil.on(nav, "click", function(event){
      var event = EventUtil.getEvent(event);
      var target = EventUtil.getTarget(event);
      var children = this.children;
      var i, len, anchor, obj={};
      for(i=0, len=children.length; i&lt;len; i++){
          if(children[i] === target){
              obj.index = i;
              anchor = target.getElementsByTagName("a")[0];
              obj.name = DOMUtil.text(anchor);
              obj.link = DOMUtil.prop(anchor, "href");
              break;
          }
      }
  });
</code></pre></li>
</ul>


<p><a href="http://weizhifeng.net/javascript-the-core" target="_blank" rel="external">javascript核心</a></p></li>
<li><p>javasctipt数组</p>

<ul>
<li>length</li>
<li>concat()  合并数组，可以有多个参数</li>
<li>join()    用数组的元素组成字符串   split() 字符串拆成数组</li>
<li>pop()     删除最后一个元素</li>
<li>push()    末尾添加新的元素</li>
<li>reverse() 顺序反转</li>
<li>slice(start, end) start-end-1 选取元素 原数组不会改变，会创建新的数组</li>
<li>splice()  修改数组    删除：arr.splice(1, 2)   插入：arr.splice(2,0,"black")    替换：arr.splice(2,1,"black")</li>
<li>shift()   删除第一个元素</li>
<li>unshift() 开头添加元素</li>
<li><p>sort()</p>

<pre><code>  /*** 数组去重**/
  function normalize(arr) {
      if (arr &amp;&amp; Array.isArray(arr)) {
          var i, map = {};
          for (i = arr.length; i &gt;= 0; --i) {
              if (arr[i] in map) {
                  arr.splice(i, 1);
              } else {
                  map[arr[i]] = true;
              }
          }
      }
      return arr;
  }

  /*** 用10个随机整数对应的字符串填充数组。**/
  function fillArray(arr, start, end, num) {
      start = start == undefined ? 1 : start;
      end = end == undefined ?  100 : end;
      num = num == undefined ? 10 : num;

      if (end &lt;= start) {
          end = start + 100;
      }

      var i, width = end - start;
      for (i = num; i &gt;= 1; --i) {
          arr.push('' + (Math.floor(Math.random() * width) + start));
      }
      return arr;
  }

  var input = [];
  fillArray(input, 1, 100, 10);
  input.sort(function (a, b) {
      return a - b;
  });
  console.log(input);

  normalize(input);
  console.log(input); 
</code></pre></li>
</ul>
</li>
<li><p>javascript正则表达式</p>

<p>var patt=new RegExp(pattern,modifiers);</p>

<p>var patt=/pattern/modifiers;</p>

<p>i - 修饰符是用来执行不区分大小写的匹配。</p>

<p>g - 修饰符是用于执行全文的搜索（而不是在找到第一个就停止查找,而是找到所有的匹配）。</p>

<p>patt.test()</p>

<p>patt.exec()</p>

<pre><code>    .   任意单个字符
    \w  查找单词字符
    \W  查找非单词字符
    \d  查找数字
    \D  查找非数字字符
    \s  查找空白字符
    \S  查找非空白字符
    \b  单词边界
    \B  非单词边界
    \0  null字符
    \n  查找换行符
    \f  换页符
    \r  回车符
    \t  制表符
    \v  垂直制表符
    \xxx    八进制数
    \xdd    16进制数
    \uxxxx  unicode字符
    n?  0次或1次
    ?=n 其后紧跟n的字符串
    ?!n 没有其后紧跟n的字符串
    ?:匹配pattern，但不捕获匹配结果，用做存在性检查

    匹配中文字符的正则表达式：[\u4e00-\u9fa5\uF900-\uFA2D]

    匹配特殊字符：([.*+?^${}()|[\]\/\\])

    匹配空行的正则表达式：\n[\s| ]*\r

    匹配HTML标记的正则表达式：/&lt;(.*)&gt;.*&lt;\/\1&gt;|&lt;(.*) \/?&gt;/ or /^&lt;(\w+)\s*\/?&gt;(?:&lt;\/\1&gt;|)$/

    匹配首尾空格的正则表达式：(^\s*)|(\s*$)

    匹配Email地址的正则表达式：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*

    匹配网址URL的正则表达式：http://([\w-]+\.)+[\w-]+(/[\w- ./?%&amp;=]*)?

    匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$

    匹配国内电话号码：\d{3}-\d{8}|\d{4}-\d{7}

    匹配腾讯QQ号：[1-9][\d]{4,}

    匹配中国邮政编码：[1-9]\d{5}(?!\d)

    匹配身份证：d{15}|d{18}

    匹配ip地址：(\d+).(\d+).(\d+).(\d+)，对$1$2$3$4进行分别验证

    用正则表达式限制只能输入数字：
    onkeyup="value=value.replace(/[^\d]/g,'')"
    onbeforepaste="clipboardData.setData('text',clipboardData.getData('text').replace(/[^\d]/g,''))"

    匹配文件后缀名
    var pos = str.lastIndexOf(".");
    if(pos != -1){
        return str.slice(pos+1);
    }
    var pattern = /[^\.]*$/;
    return pattern.exec(str);
    return str.match(pattern);

    判断是否是CSS文件
    var isCss = /.*\.css(?=\?|$)/
</code></pre>

<p><strong>关于非捕获性分组</strong></p>

<pre><code>    非捕获性分组：

    创建反向引用的分组，这种分组一般称为捕获性分组。同时也存在一种非捕获性分组。它不会创建反向引用，因为在比较长的正则表达式中，分组多了会很影响效率。所以使用非捕获性分组。

    创建非捕获性分组是这样的(?:开始然后写表达式。例如:

    var str='#123456';

    //var oReg=/#(\w+)/g; 　　//()的作用有多种，其中一咱就是捕获性分组，有些书上也称做“反向引用”，


    var oReg=/#(?:\w+)/;　　//非捕获性分组 ，在()左边添加 ?:

    alert(oReg.test(str));　　 //true

    alert(RegExp.$1);　　//　　''  返回空值，由此可以它虽然满足了我们的要求但却并没有创建引用，而如果使用捕获性分组，这里就会返回一个 123456 ，因为RegExp.$1 “记忆”下了匹配的字符。

    注意：在JavaScript中，分组匹配的结果是存储在RegExp中的，如果我们使用的是捕获性分组，那么就都可以通过RegExp.$1,RegExp.$2...来取得相应的分组匹配结果，第一个()表示RegExp.$1,第二个()表示RegExp.$2,依此类推。。。
</code></pre></li>
<li><p>javascript判断数据类型</p>

<ol>
<li><p>原型</p>

<pre><code> Object.prototype.toString.call(a) === ‘[object String]’
 Object.prototype.toString.call(b) === ‘[object Number]’
 Object.prototype.toString.call(c) === ‘[object Array]’
 Object.prototype.toString.call(d) === ‘[object Date]’
 Object.prototype.toString.call(e) === ‘[object Function]’
 Object.prototype.toString.call(f) === ‘[object Function]’

 语义化的javascript代码为：

 function isType(type){
     return function(obj){
         return Object.prototype.toString.call(o) === '[Object' + type + ']';
     }
 }

 var isString = isType('String');
 var isObject = isType('object');
 var isArray = isType('Array');

 isString("I am Jennifer");
</code></pre></li>
<li>typeof用以获取一个变量或者表达式的类型，typeof一般只能返回如下几个结果：number,boolean,string,function（函数）,object（NULL,数组，对象）,undefined</li>
<li>instanceof考察A.__proto__ === B.prototype?</li>
<li>constructor</li>
<li>hasOwnProperty判断是否是对象自己的方法</li>
<li>in判断是否是对象或者原型的方法</li>
</ol>
</li>
<li><p>如何使用URL拆分出protocol， host，port， query等</p>

<pre><code>URL即统一资源定位符 (Uniform Resource Locator, URL)，完整的URL由这几个部分构成：
scheme://host:port/path?query#fragment
scheme:通信协议，常用的http,ftp,maito等。
host:主机，服务器(计算机)域名系统 (DNS) 主机名或 IP 地址。
port:端口号，整数，可选，省略时使用方案的默认端口，如http的默认端口为80。
path:路径，由零或多个"/"符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。
query:查询，可选，用于给动态网页（如使用CGI、ISAPI、PHP/JSP/ASP/ASP.NET等技术制作的网页）传递参数，可有多个参数，用"&amp;"符号隔开，每个参数的名和值用"="符号隔开。
fragment:信息片断，字符串，用于指定网络资源中的片断。例如一个网页中有多个名词解释，可使用fragment直接定位到某一名词解释。(也称为锚点)
下面我们举例一个URL，然后获得它的各个组成部分。

http://www.nowamagic.net/newsDetail.php?id=65
window.location.href
可以获得整个URL字符串（在浏览器中就是完整的地址栏）
var test = window.location.href;
alert(test);
程序返回 http://www.nowamagic.net/newsDetail.php?id=65

window.location.protocol
可以获得 URL 的协议部分
var test = window.location.protocol;
alert(test);
程序返回 http:

window.location.host
可以获得 URL 的主机部分
var test = window.location.host;
alert(test);
程序返回 www.nowamagic.net

window.location.port
可以获得 URL 的端口部分
var test = window.location.port;
alert(test);
如果采用默认的80端口(update:即使添加了:80)，那么返回值并不是默认的80而是空字符。

window.location.pathname
获得 URL 的路径部分（就是文件地址）
var test = window.location.pathname;
alert(test);

window.location.search
获得查询（参数）部分，除了给动态语言赋值以外，我们同样可以给静态页面，并使用javascript来获得相信应的参数值。
var test = window.location.search;
alert(test);

window.location.hash
获得锚点。
var test = window.location.hash;
alert(test);
</code></pre></li>
<li><p>javascript函数式编程</p>

<p>在javascript中</p>

<ol>
<li>函数是第一等公民</li>
<li>函数可以返回函数</li>
<li>词法上支持闭包</li>
</ol>


<p>如何有效利用闭包和作用域是成为一个伟大的javascript开发者的关键</p>

<p><strong>函数柯里化</strong></p>

<p>柯里化是这样的一个转换过程，把接受多个参数的函数变换成接受一个单一参数的函数，如果其他的函数是必要时，返回接受余下的参数且返回结果的新函数</p>

<p>函数柯里化允许和鼓励分隔复杂功能变成更小更容易分析的部分。这些小的逻辑单元显然是更容易理解和测试的，然后你的应用就会变成干净而整洁的组合，由一些小单元组成的组合。</p>

<ul>
<li>柯里化是将多个参数合成一个object参数，这个object字段不是固定的，对于同一个函数来说，无论后期参数的顺序、数量、类型如何变化，接口部分是不变的，所以适合作为构造方法来用；</li>
<li>柯里化可以解决动态参数的问题，在不需要改变接口的情况下可以新增不同特性，且对调用端透明，解决了js里面没有重载带来的一些麻烦；</li>
<li>柯里化有3个典型应用：参数复用，提前返回、延迟计算</li>
<li>柯里化：把参数数组首个砍掉；反柯里化：把某个参数塞到参数数组的第一个。柯里化跟反柯里化都可以返回新函数，相比原函数，他们接受的参数一个是被砍头过的，一个是接头过的</li>
<li><a href="http://www.zhangxinxu.com/wordpress/2013/02/js-currying/" target="_blank" rel="external">参考</a></li>
</ul>
</li>
<li><p>内存泄露/垃圾回收</p>

<p>垃圾回收 garbage collector--GC</p>

<p>内存泄露 memory leak</p></li>
<li><p>javascript笔试题</p>

<ul>
<li><p>给基本数据类型添加属性时，不报错，但是取值为undefined</p>

<pre><code>  var a = 10;
  a.pro = 10;
  console.log(a.pro + a);//NaN

  var s = "hello";
  s.pro = "world";
  console.log(s.pro + s);//undefinedhello
</code></pre></li>
<li><p>console.table(object数据)//ie不支持</p></li>
<li><p>变量替换</p>

<pre><code>  var a = 1, b = 2;
  a = [b, b = a][0];
</code></pre></li>
<li><p>读程序写结果</p>

<pre><code>  function test(){

      var a=1;

      setTimeout(function(){

          alert(a);

          a=3;
          //var a= 3;

      },1000);

      a=2;

      setTimeout(function(){

          alert(a);

          a=4;

          //var a= 4;

      },3000);

  }

  test();
  答案是：2 3 使用var赋值时：undefined undefined
</code></pre></li>
<li><p>读程序写结果</p>

<pre><code>  function tr42(){

      var a2,b2;
      a2 = {"c":1};
      b2 = a2;
      alert(b2.c);
      a2.c = 2;
      alert(b2.c);
      console.log("a:"+a2);
      console.log("b:"+b2);
      a2={"c":3};
      alert(b2.c);
      console.log("a:"+a2);
      console.log("b:"+b2);
      a2.c=4;
      alert(b2.c);
      console.log("a:"+a2);
      console.log("b:"+b2);
  }
  tr42();

  答案是：
  1
  2
  a: [Object Object]
  b: [Object Object]
  2
  a: [Object Object]
  b: [Object Object]
  2
  a: [Object Object]
  b: [Object Object]

  &gt; var a = [1, 2]
  &lt; undefined
  &gt; a
  &lt; [1, 2]
  &gt; var b = a;
  &lt; undefined
  &gt; b
  &lt; [1, 2]
  &gt; a[2] = b[1];
  &lt; 2
  &gt; a
  &lt; [1, 2, 2]
  &gt; b
  &lt; [1, 2, 2]
  &gt; b[2] = 3;
  &lt; 3
  &gt; a
  &lt; [1, 2, 3]
  &gt; b
  &lt; [1, 2, 3]
  &gt; a = [3, 4, 5]
</code></pre></li>
<li><p>读程序写结果</p>

<pre><code>  var foo=1;
  function main(){
      this.a =4;
      console.log("foo: " + foo);// undefined
      //var foo=2;
      foo=2;
      console.log("this: " + this);
      console.log(this);
      console.log("foo: " + foo);
      console.log("this.a: " + this.a);
      console.log("this.foo: " + this.foo);// undefined
      this.foo = 3;
  }
  var m1 = main();
  var m2 = new main();

  答案是：
  [Log] foo: 1
  [Log] this: [object Window]
  [Log] Window对象
  [Log] foo: 2
  [Log] this.a: 4
  [Log] this.foo: 2
  [Log] foo: 3
  [Log] this: [object Object]
  [Log] main对象
  [Log] foo: 2
  [Log] this.a: 4
  [Log] this.foo: undefined

  var声明之后
  foo: undefined
  this: [object Window]
  Window
  foo: 2
  this.a: 4
  this.foo: 1
  foo: undefined
  this: [object Object]
  main
  foo: 2
  this.a: 4
  this.foo: undefined//浅拷贝
</code></pre></li>
<li><p>读程序写结果</p>

<pre><code>  [].forEach.call($$(""), function(a){
      a.style.outline = "1px solid #" + (~~(Math.random()*(1&lt;&lt;24))).toString(16);
  });
  | 0 和 ~~都能实现取整功能，比parseInt和Math.round()要快
  !!object可以实现把object转换成布尔值
  $$实现了document.querySelectorAll功能
</code></pre></li>
<li><p><a href="http://www.ibm.com/developerworks/cn/web/1308_caiys_jsload/" target="_blank" rel="external">异步加载js并执行回调函数</a></p>

<pre><code>  function loadScript(url,callback){ 
     var script = document.createElement("script") 
     script.type = "text/javascript"; 
     script.async = true;
     script.defer = true;
     if (script.readyState){//IE 
        script.onreadystatechange = function(){ 
           if (script.readyState ==  "loaded" || script.readyState == "complete"){ 
              script.onreadystatechange = null;

              callback(); 
           } 
        }; 
     } else { //Others: Firefox, Safari, Chrome, and Opera 
        script.onload = function(){ 
            callback(); 
        }; 
     } 
     script.src = url; 
     document.body.appendChild(script);
     //document.getElementsByTagName("head")[0].appendChild(script);
  }

  var xhr = new XMLHttpRequest();
  xhr.open("get", "script1.js", true);
  xhr.onreadystatechange = function(){
      if (xhr.readyState == 4){
          if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304){
              var script = document.createElement ("script");
              script.type = "text/javascript";
              script.text = xhr.responseText;
              document.body.appendChild(script);
          }
      }
  };
  xhr.send(null);
</code></pre>

<p>  总结：</p>

<p>  减少 JavaScript 对性能的影响有以下几种方法：</p>

<ol>
<li><p> 将所有的<script>标签放到页面底部，也就是</body>闭合标签之前，这能确保在脚本执行前页面已经完成了渲染。</p></li>
<li><p> 尽可能地合并脚本。页面中的<script>标签越少，加载也就越快，响应也越迅速。无论是外链脚本还是内嵌脚本都是如此。</p></li>
<li><p> 采用无阻塞下载 JavaScript 脚本的方法：使用<script>标签的 defer 属性（仅适用于 IE 和 Firefox 3.5 以上版本）或者HTML5<script>标签的async属性</p></li>
<li><p> 使用动态创建的<script>元素来下载并执行代码；</p></li>
<li><p> 使用 XHR 对象下载 JavaScript 代码并注入页面中。</p></li>
</ol>
</li>
<li><p>格式化定义对象--javascript语义化</p>

<pre><code>  var repos = [];
  function register(obj){
      repos[obj.name] = obj;
  }
  register({
      name: "a",
      content: {}
  });
</code></pre></li>
<li>读程序写结果</li>
</ul>
</li>
<li><p>模板引擎</p>

<p>帮助组织和维护代码结构，提高代码编写效率、降低维护成本，如nodejs中使用的ejs模板--<em>数据简单，只需填充，好上手</em></p>

<p>前端模板：模板是一种语义化的、可读的、简练的视图结构表达，在前端开发中有着非常重要的作用。前端模板大致有以下几种使用方式：最原始的字符串拼接；使用；模板预编译为js。</p>

<p><a href="http://garann.github.io/template-chooser/">如何选择js模板引擎</a></p>

<ol>
<li><p><a href="http://juicer.name/">Juicer</a></p>

<p> <a href="http://juicer.name/docs/docs_zh_cn.html">Juicer中文文档</a></p>

<pre><code> HTML 代码:
 &lt;script id="tpl" type="text/template"&gt;
     &lt;ul&gt;
         {@each list as it,index}
             &lt;li&gt;${it.name} (index: ${index})&lt;/li&gt;
         {@/each}
         {@each blah as it}
             &lt;li&gt;
                 num: ${it.num} &lt;br /&gt;
                 {@if it.num==3}
                     {@each it.inner as it2}
                         ${it2.time} &lt;br /&gt;
                     {@/each}
                 {@/if}
             &lt;/li&gt;
         {@/each}
     &lt;/ul&gt;
 &lt;/script&gt;

 Javascript 代码:          
 var data = {
     list: [
         {name:' guokai', show: true},
         {name:' benben', show: false},
         {name:' dierbaby', show: true}
     ],
     blah: [
         {num: 1},
         {num: 2},
         {num: 3, inner:[
             {'time': '15:00'},
             {'time': '16:00'},
             {'time': '17:00'},
             {'time': '18:00'}
         ]},
         {num: 4}
     ]
 };

 var tpl = document.getElementById('tpl').innerHTML;
 var html = juicer(tpl, data);
</code></pre></li>
</ol>
</li>
<li><p><a href="http://www.stubbornella.org/content/2009/03/27/reflows-repaints-css-performance-making-your-javascript-slow/">reflow和repaint</a></p>

<p><a href="http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html#rd?sukey=a805c0b270074a06dab0cfe04cdbbbf65739611a611c7397adeaa74c6955ac9b3aa129e7bde9cbfb1c9a7fd6c51872b7">网页性能管理详解</a>repaint（重绘）是在元素的外观经过改变，但没有改变页面layout布局的情况下发生，如改变visibility、background、color等，当repaint发生时，浏览器会验证DOM树上所有其他节点的visibility属性；reflow（回流）则是引起DOM操作相关脚本执行时低性能的一个关键点，页面上任一节点触发reflow，都会导致他的子节点、祖先节点重新渲染。</p>

<p>触发reflow的几种情况</p>

<ol>
<li>窗口大小改变</li>
<li>文字的font各样式属性改变</li>
<li>stylesheet添加/删除</li>
<li>改变内容，如用户在输入框中敲字</li>
<li>激活伪类</li>
<li>操作class属性</li>
<li>JS操作DOM</li>
<li>读取offsetWidth/clientWidth/scrollWidth等layout属性</li>
<li>设置style属性</li>
</ol>


<p>如何降低影响</p>

<ul>
<li>尽可能限制reflow的影响范围</li>
<li>通过设置style属性改变节点样式的话，每设置一次都会导致一次reflow，最好通过设置class的方式</li>
<li>实现动画的元素的position属性应当设为fixed或者absolute，这样不会影响其他元素的布局</li>
<li>...</li>
</ul>
</li>
</ol>


<h3>JQuery</h3>

<ol>
<li><p>名词解释</p>

<ul>
<li>chaining：允许在一条语句中对同一个元素添加多个方法</li>
<li><p><em>deferreds</em>：是jquery回调函数的解决方案，他解决了如何处理耗时操作的问题，对那些操作提供了很好的控制，以及统一的编程接口，<em>参考阮一峰日志</em></p>

<pre><code>  //指定同一个对象的多个回调函数
  $.ajax("test.html")
      .done(function(){alert("success");})
      .fail(function(){alert("error");})
      .done(function(){alert("success twice");});
  //为多个操作指定回调函数
  $.when($.ajax("test1.html"), $.ajax("test2.html"))
      .done(function(){alert("success");})
      .fail(function(){alert("error");})
  //针对耗时操作怎么办
  var dtd = $.Deferred();//创建新的deferred对象，全局的，其状态可以被任意改变
  var wait = function(dtd){
      var tasks = function(){
          alert("success");
          dtd.resolve();//改变deferred对象的执行状态，有3种：未完成(继续等待或调用progress方法)，已完成(done方法)和已失败(fail方法)
          // dtd.reject();//调用fail方法
      }
      setTimeout(tasks, 5000);
      // return dtd;
      return dtd.promise();//返回promise对象，只开放与改变状态无关(done/fail)的方法，避免对执行状态的更改
  }
  var d = wait(dtd);
  $.when(d)
      .done(function(){alert("success");})
      .fail(function(){alert("error");});
  d.resolve();//语句无效
  //第二种方法
  var wait = function(dtd){
      var dtd = $.Deferred();//在函数内部创建
      var tasks = function(){
          alert("success");
          dtd.resolve();//改变deferred对象的执行状态
      }
      setTimeout(tasks, 5000);
      // return dtd;
      return dtd.promise();//返回promise对象
  }
  // $.when(wait())
  //  .done(function(){alert("success");})
  //  .fail(function(){alert("error");});
  $.Deferred(wait)
      .done(function(){alert("success");})
      .fail(function(){alert("error");});
  //第三种方法
  var dtd = $.Deferred();
  var wait = function(dtd){   
      var tasks = function(){
          alert("success");
          dtd.resolve();//改变deferred对象的执行状态
      }
      setTimeout(tasks, 5000);
      // return dtd;  
  }
  dtd.promise(wait);//返回promise对象
  wait.done(function(){alert("success");})
      .fail(function(){alert("error");});
  wait(dtd);
</code></pre></li>
<li><p>.end()函数：结束当前链条中的最近的筛选操作，并将匹配元素集还原为之前的状态</p></li>
<li>.eq()函数：返回jquery对象，可以使用jquery方法</li>
<li>.get()函数：<strong>返回原生DOM对象</strong></li>
</ul>
</li>
<li><p>传递给jQuery方法的值</p>

<ul>
<li>字符串：选择器、html</li>
<li>回调函数</li>
<li>HTML元素</li>
<li>对象、数组等</li>
</ul>
</li>
<li><p>几种<strong>事件绑定</strong>方法</p>

<ul>
<li>.bind()将事件处理函数绑定到元素上</li>
<li>.live()将事件处理函数绑定到一个特定的父元素上，事件冒泡到这个级别时，再对目标元素执行事件处理函数，默认绑定到document</li>
<li><p>.delegate()将事件处理函数绑定到一个特定的父元素上，事件冒泡到这个级别时，再对目标元素执行事件处理函数</p>

<pre><code>  $("td", $("table")).live("hover", function(){
      //$(this).toggleClass("hover");
  })
  $("table").delegate("td", "hover", function(){
      $(this).toggleClass("hover");
  });
</code></pre></li>
<li><p>.on()是对三种方式的替代，jquery中上面3种内部都是用on实现的</p></li>
</ul>


<p> <a href="http://kb.cnblogs.com/page/94469/">bind live delegate区别</a></p>

<p> <a href="http://www.cnblogs.com/changchangcc520/archive/2007/12/08/988088.html">javascript动态给元素绑定事件</a></p></li>
<li><p><strong>jquery.cssHooks</strong></p>

<p> 标准化CSS属性名或创建自定义属性</p>

<pre><code> (function($){
     if(!$.cssHooks){
         //jquery1.4.3+
     }

     function styleSupport(prop){
         var vendorProp, supportedProp, capProp = prop.charAt(0).toUpperCase() + prop.slice(1),
             prefixes = ["Moz", "Webkit", "O", "ms"],
             div = document.createElement("div");

         if(prop in div.style){
             supportedProp = prop;
         }else{
             for(var i=0; i &lt; prefixes.length; i++){
                 vendorProp = prefixes[i] + capProp;
                 if(vendorProp in div.style){
                     supportedProp = vendorProp;
                     break;
                 }
             }
         }
         div = null;
         $.support[prop] = supportedProp;
         return supportedProp;
     }

     var borderRadius = styleSupport("borderRadius");
     if(borderRadius &amp;&amp; borderRadius != "borderRadius"){
         $.cssHooks.borderRadius = {
             get: function(elem, computed, extra){return $.css(elem, borderRadius); },
             set: function(elem, value){elem.style[borderRadius] = value; }
         };
     }
 })(jQuery); 
</code></pre></li>
<li><p>一些好用的代码段<a href="http://blog.jobbole.com/18513">50个jquery代码段</a></p>

<ul>
<li>has检查是否包含某个类或元素</li>
<li>使用jquery切换样式表（<strong>响应式布局</strong>）：$("link[media='screen']").attr("href", "other.css")</li>
<li>使用toggleClass进行类切换，代替addClass和removeClass</li>
<li>检测浏览器

<ul>
<li>IE：$.browser.msie</li>
<li>safari $.browser.safari</li>
<li>firefox $.browser.mozilla</li>
<li>版本 $.browser.version</li>
</ul>
</li>
<li>replaceWith函数</li>
<li>元素是否为空：$("#id").html() == null</li>
<li><p>从一个未排序的集合中找出某个元素的索引号</p>

<pre><code>  $("ul &gt; li").click(function()){
      var index = $(this).prevAll().length;
  }
</code></pre></li>
<li>option:selected radio:checked</li>
<li>隐藏包含某个值的文本的元素$("p.value.<strong>cantains</strong>('xxx')").hide();</li>
<li><p>自动滚屏</p>

<pre><code>  jQuery.fn.autoScroll = function(selector){
      $("html, body").animate(
          {scrollTop: $(selector).offset().top},
          500
      )
  };
  $('.area_name').autoScroll();
</code></pre></li>
<li><p>禁止右键单击上下文菜单</p>

<pre><code>  $(document).bind("context menu", function(e){return false; });
</code></pre></li>
<li><p>使用jquery检测右键和左键鼠标单击情况</p>

<pre><code>  $("#someelement").live("click", function(e){
      if((!$.browser.msie &amp;&amp; e.buton == 0) || (!$.browser.msie &amp;&amp; e.buton == 1)){
          //left
      }
      else if(e.button == 2){
          //right
      }
  });
</code></pre></li>
<li><p>input域默认值动态显示</p>

<pre><code>  swap_val = [];
  $(".swap").each(function(i){
      swap_val[i] = $(this).val();
      $(this).focusin(function(){
          if($(this).val() == swap_val[i]){
              $(this).val() = "";
          }
      }).focusout(function(){
          if($(this).val() == ""){
              $(this).val() = swap_val[i];
          }
      });
  });
</code></pre></li>
<li>测试元素是否可见.is(":visible") == true</li>
<li><p>元素置于中心位置</p>

<pre><code>  jQuery.fn.center = function(){
      this.css("position", "absolute");
      this.css("top", ($(window).height()-this.height()) + $(window).scrollTop() + "px");
      this.css("left", ($(window).width()-this.width()) / 2 + $(window).scrollLeft() + "px");
      return this;
  }
</code></pre></li>
<li><p>在弹出框打开链接</p>

<pre><code>  jQuery(".popup").delegate("click", function(){
      newwindow = window.open($(this).attr("href"), "", "height=200,width=150");
      if(window.focus){
          newwindow.focus();
      }
      return false;
  });
</code></pre></li>
<li><p>在新的选项卡打开链接</p>

<pre><code>  jQuery(".newTab").delegate("click", function(){
      newwindow = window.open($(this).attr("href"));
      jQuery(this).target = "_blank";
      return false;
  });
</code></pre></li>
<li>遍历

<ul>
<li>closest 选择最近的元素</li>
<li><p>siblings 选择兄弟元素</p>

<pre><code>  $("nav li").click(function(){
      $(this).addClass("active").siblings().removeClass("active");
  })
</code></pre></li>
</ul>
</li>
<li><p>检查是否启用cookie</p>

<pre><code>  var dt = new Date();
  dt.setSeconds(dt.getSeconds() + 60);
  document.cookie = "cookietest=1; expires=" + dt.toGMTString();
  var cookieEnabled = document.cookie.indexOf("cookietest=") != -1;
</code></pre></li>
</ul>
</li>
<li><p><a href="http://www.cnblogs.com/Showshare/p/different-between-attr-and-prop.html">jquery中attr和prop</a></p>

<pre><code> 在jQuery中，attr函数和prop函数都用于设置或获取指定的属性，它们的参数和用法也几乎完全相同。

 但不得不说的是，这两个函数的用处却并大不相同。下面我们来详细介绍这两个函数之间的区别。

 1、操作对象不同

 很明显，attr和prop分别是单词attribute和property的缩写，并且它们均表示"属性"的意思。

 不过，在jQuery中，attribute和property却是两个不同的概念。attribute表示HTML文档节点的属性，property表示JS对象的属性。

 &lt;!-- 这里的id、class、data_id均是该元素文档节点的attribute --&gt;
 &lt;div id="message" class="test" data_id="123"&gt;&lt;/div&gt;

 &lt;script type="text/javascript"&gt;
 // 这里的name、age、url均是obj的property
 var obj = { name: "CodePlayer", age: 18, url: "http:/ /www.365mini.com/" };
 &lt;/script&gt;
 在jQuery中，prop()函数的设计目标是用于设置或获取指定DOM元素(指的是JS对象，Element类型)上的属性(property)；attr()函数的设计目标是用于设置或获取指定DOM元素所对应的文档节点上的属性(attribute)。

 &lt;!-- attr()函数针对的是该文档节点的attribute --&gt;
 &lt;div id="message" class="test" data_id="123"&gt;&lt;/div&gt;

 &lt;script type="text/javascript"&gt;
 // prop()函数针对的是该DOM元素(msg)自身的property
 var msg = document.getElementById("message");
 var $msg = $(msg);
 &lt;/script&gt;
 当然，在jQuery的底层实现中，函数attr()和prop()的功能都是通过JS原生的Element对象(如上述代码中的msg)实现的。attr()函数主要依赖的是Element对象的getAttribute()和setAttribute()两个方法。prop()函数主要依赖的则是JS中原生的对象属性获取和设置方式。

 &lt;div id="message" class="test" data_id="123"&gt;&lt;/div&gt;
 &lt;script type="text/javascript"&gt;
 var msg = document.getElementById("message");
 var $msg = $(msg);

 /* *** attr()依赖的是Element对象的element.getAttribute( attribute ) 和 element.setAttribute( attribute, value ) *** */

 // 相当于 msg.setAttribute("data_id", 145);
 $msg.attr("data_id", 145);

 // 相当于 msg.getAttribute("data_id");
 var dataId = $msg.attr("data_id"); // 145

 /* *** attr()依赖的是JS原生的 element[property] 和 element[property] = value; *** */

 // 相当于 msg["pid"] = "pid值";
 $msg.prop("pid", "pid值");

 // 相当于 msg["pid"];
 var testProp = $msg.prop("pid"); // pid值
 &lt;/script&gt;
 当然，jQuery对这些操作方式进行了封装，使我们操作起来更加方便(比如以对象形式同时设置多个属性)，并且实现了跨浏览器兼容。

 此外，虽然prop()针对的是DOM元素的property，而不是元素节点的attribute。不过DOM元素某些属性的更改也会影响到元素节点上对应的属性。例如，property的id对应attribute的id，property的className对应attribute的class。

 &lt;div id="message" class="test" data_id="123"&gt;&lt;/div&gt;
 &lt;script type="text/javascript"&gt;
 var msg = document.getElementById("message");
 var $msg = $(msg);

 document.writeln( $msg.attr("class") ); // test
 $msg.prop("className", "newTest");
 // 修改className(property)导致class(attitude)也随之更改
 document.writeln( $msg.attr("class") ); // newTest
 &lt;/script&gt;
 运行代码

 2、应用版本不同

 attr()是jQuery 1.0版本就有的函数，prop()是jQuery 1.6版本新增的函数。毫无疑问，在1.6之前，你只能使用attr()函数；1.6及以后版本，你可以根据实际需要选择对应的函数。

 3、用于设置的属性值类型不同

 由于attr()函数操作的是文档节点的属性，因此设置的属性值只能是字符串类型，如果不是字符串类型，也会调用其toString()方法，将其转为字符串类型。

 prop()函数操作的是JS对象的属性，因此设置的属性值可以为包括数组和对象在内的任意类型。

 4、其他细节问题

 在jQuery 1.6之前，只有attr()函数可用，该函数不仅承担了attribute的设置和获取工作，还同时承担了property的设置和获取工作。例如：在jQuery 1.6之前，attr()也可以设置或获取tagName、className、nodeName、nodeType等DOM元素的property。

 直到jQuery 1.6新增prop()函数，并用来承担property的设置或获取工作之后，attr()才只用来负责attribute的设置和获取工作。

 此外，对于表单元素的checked、selected、disabled等属性，在jQuery 1.6之前，attr()获取这些属性的返回值为Boolean类型：如果被选中(或禁用)就返回true，否则返回false。

 但是从1.6开始，使用attr()获取这些属性的返回值为String类型，如果被选中(或禁用)就返回checked、selected或disabled，否则(即元素节点没有该属性)返回undefined。并且，在某些版本中，这些属性值表示文档加载时的初始状态值，即使之后更改了这些元素的选中(或禁用)状态，对应的属性值也不会发生改变。

 因为jQuery认为：attribute的checked、selected、disabled就是表示该属性初始状态的值，property的checked、selected、disabled才表示该属性实时状态的值(值为true或false)。

 因此，在jQuery 1.6及以后版本中，请使用prop()函数来设置或获取checked、selected、disabled等属性。对于其它能够用prop()实现的操作，也尽量使用prop()函数。

 &lt;input id="uid" type="checkbox" checked="checked" value="1"&gt;

 &lt;script type="text/javascript"&gt;
 // 当前jQuery版本为1.11.1
 var uid = document.getElementById("uid");
 var $uid = $(uid);

 document.writeln( $uid.attr("checked") ); // checked
 document.writeln( $uid.prop("checked") ); // true

 // 取消复选框uid的选中(将其设为false即可)
 // 相当于 uid.checked = false;
 $uid.prop("checked", false);

 // attr()获取的是初始状态的值，即使取消了选中，也不会改变
 document.writeln( $uid.attr("checked") ); // checked
 // prop()获取的值已经发生变化
 document.writeln( $uid.prop("checked") ); // false
 &lt;/script&gt;
</code></pre></li>
</ol>

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p><a href="http://github.com/qiu-deqing/FE-interview">前端面试题</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

</body>
</html></script></p></li></ol></li></ul></li></ol></body></html>
    
  </div>

 </div>

        

        
          <div class="comments" id="comments">
            
              <div class="ds-thread" data-thread-key="frontend_note_1.html"
                   data-title="" data-url="http://www.xiaojunxie.com/frontend_note_1.html">
              </div>
            
          </div>
        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/image_128X128.ico" alt="谢晓君" itemprop="image"/>
          <p class="site-author-name" itemprop="name">谢晓君</p>
        </div>
        <p class="site-description motion-element" itemprop="description">Good artists copy, best artists steal.</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">14</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">3</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">10</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/sallymew" target="_blank">GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/sallymew" target="_blank">Weibo</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/jenniferxie" target="_blank">ZhiHu</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">谢晓君</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"xiaojunxie"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    

    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  


  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
